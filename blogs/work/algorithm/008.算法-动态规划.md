---
title: 算法-动态规划
date: 2022-03-01
categories:
 - 算法
tags:
 - leetcode
 - 动态规划（算法）
sidebar: 'auto'
---



### 动态规划核心思想

**最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的**

动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。

找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路，经常刷题的朋友应该能体会。

**画图是找有无重复问题的最佳方法**



### [零钱兑换](https://leetcode-cn.com/problems/coin-change/)（经典）

![image-20220315173540980](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220315173540980.png) 

> 思路：最优子结构问题，递归 和 动态规划(具有**重叠子问题**)
>
> ![image-20220315180058993](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220315180058993.png) 
>
> 1、**确定 base case**，显然目标金额 `amount` 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。
>
> 2、**确定「状态」，也就是原问题和子问题中会变化的变量**。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 `amount`。
>
> 3、**确定「选择」，也就是导致「状态」产生变化的行为**。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。
>
> 4、**明确 `dp` 函数/数组的定义**：输入一个目标金额 `n`，返回凑出目标金额 `n` 的最少硬币数量。

![image-20220315173900272](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220315173900272.png) 

```java 
// 递归写法
  // 带备忘录的递归
    int[] memo;

    public int coinChange(int[] coins, int amount) {
        memo  = new int[amount + 1];
        // dp数组全都初始化为特殊值
        Arrays.fill(memo, -666);
        return dp(coins, amount);
    }

    int dp(int[] coins, int amount){
        if(amount == 0) return 0;
        if(amount < 0) return -1;
        //查看备忘录，防止重复计算
        if(memo[amount] != -666) return memo[amount];

        int res = Integer.MAX_VALUE;
        for(int coin : coins){
            //计算子问题的结果
            int subProblem = dp(coins, amount - coin);
            // 子问题无解则跳过
            if (subProblem == -1) continue;
            // 在子问题中选择最优解，然后加1
            res = Math.min(res, subProblem+1);
        }
        //把计算结果存入备忘录
        memo[amount] = (res == Integer.MAX_VALUE) ? -1 : res;
        return memo[amount];
    }
```

![image-20220315180118099](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220315180118099.png) 

```java
    public int coinChange(int[] coins, int amount) {
        // 定义和初始化dp 数组
        int[] dp = new int[amount+1];
        Arrays.fill(dp, amount+1);//只要给一个不可能的值就行
        
        // base case
        dp[0] = 0;
        //外层遍历所有状态的所有可能值
        for(int i=0; i < dp.length; i++){
            // 内层 for 循环在求所有选择的最小值
            for(coin:coins){
                if (i-coins<0){ //子问题无解跳过
                    continue;
                }
                dp[i] = Math.min(dp[i],1+dp[i-coin]);
            }
        }
        return (dp[amount] == amount + 1) ? -1 : dp[amount];
    }
```





### [最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)（经典）

![image-20220317085733692](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220317085733692.png) 

> 思路：我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 `dp[0...i-1]` 都已经被算出来了，然后问自己：怎么通过这些结果算出 `dp[i]`？（**和递归一样，想到子问题已经解决，当前 i 的结果怎么算**）
>
> 1.首先要定义清楚 dp 数组的含义，即 `dp[i]` 的值到底代表着什么？
>
> **我们的定义是这样的：`dp[i]` 表示以 `nums[i]` 这个数结尾的最长递增子序列的长度**。
>
> ![img](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/gif1.gif)

```java
  public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length]; //定义新dp数组记录每个位置的最长子序列
        Arrays.fill(dp,1);//初始化dp;
        int len = nums.length;
        int max = 0; //记录最大值，最后一个dp不是最大结果，只是由它结尾的子序列最大
        for(int i=0;i<len;i++){
            for(int j=0 ; j<i;j++){
               if(nums[j]>=nums[i]) continue;
               dp[i] = Math.max(dp[i],dp[j]+1);
            }
               max = Math.max(dp[i],max);
        }
        return max;
    }
```



### [下降路径最小和](https://leetcode-cn.com/problems/minimum-falling-path-sum/)（二维）

![image-20220317151316744](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220317151316744.png)

> 思路：定义dp 数组的意义： 用于记录到达这个下标的最小路径，注意第一列和最后一列的处理，下降规则根据题意

```java
 public int minFallingPathSum(int[][] matrix) {
        int len = matrix.length;
        int[][] dp = new int[len][len];
         for (int l = 0; l < len; l++) { //初始化数组
            Arrays.fill(dp[l], Integer.MAX_VALUE);
        }
        for(int i =0;i<len;i++){
            for(int j=0;j<len;j++){
                if(i==0){
                    dp[i][j] = matrix[i][j];
                    continue;
                } 
                if(j==0){
                    dp[i][j] = min( Integer.MAX_VALUE,dp[i-1][j],dp[i-1][j+1])+matrix[i][j];
                }else if(j==len-1){
                    dp[i][j] = min( Integer.MAX_VALUE,dp[i-1][j],dp[i-1][j-1])+matrix[i][j];
                }else{
                     dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])+matrix[i][j];
                }
                
            }

        }

        int min =  Integer.MAX_VALUE;
        for(int k=0;k<len;k++){
            min = Math.min(dp[len-1][k],min);
        }

        return min;
    }
    public int min(int a,int b,int c){
        return c < (a < b ? a : b) ? c : (a < b ? a : b);
    }
```



### [最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)（二维）

![image-20220318170936512](C:/Users/16843/AppData/Roaming/Typora/typora-user-images/image-20220318170936512.png) 



> 思路：求最值-->暴力穷举（不现实），动态规划
>
> 首先定义dp 数组是关键，其次是根据题意得出状态转移方程
>
> 这里的变量是两个字符串，要在dp中记录所有的值，一维肯定不行，
>
> 经典的双字符串动态规划问题。用两个指针 `i, j` 在两个字符串上游走，这就是「状态」，字符串中的每个字符都有两种「选择」，要么在 `lcs` 中，要么不在。
>
> ![image-2022 0318183039871](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220318183039871.png) 
>
> `dp[i][j]` 的含义是：对于 `s1[1..i]` 和 `s2[1..j]`，它们的 LCS 长度是 `dp[i][j]`。
>
> ![ ](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220318182944443.png)  

```java
public int longestCommonSubsequence(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // 定义：s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度为 dp[i][j]
        int[][] dp = new int[m + 1][n + 1];
        // 目标：s1[0..m-1] 和 s2[0..n-1] 的 lcs 长度，即 dp[m][n]
        // base case: dp[0][..] = dp[..][0] = 0

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 现在 i 和 j 从 1 开始，所以要减一
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    // s1[i-1] 和 s2[j-1] 必然在 lcs 中
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    // s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }

        return dp[m][n];
 }
```



### [两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

![image-20220318183409223](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220318183409223.png) 

> 思路：思路LCS一模一样，记录最长公共子序列长度，再算最小步数

```java
    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        int[][] dp =new int[m+1][n+1];
        for(int i =1;i <= m; i++){
            for(int j = 1; j<=n; j++){
                if(word1.charAt(i-1) == word2.charAt(j-1)){
                     dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                     dp[i][j]= Math.max(dp[i-1][j],dp[i][j-1]);
                }
            
            }
        }
        return m+n-2*dp[m][n];
    }
```



### [两个字符串的最小ASCII删除和](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/)(lcs进阶)

![image-20220318184141102](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220318184141102.png) 

> 思路：题目是要求删除字符的ASCll值的最小和，转化一下思考方向---->不就是把最长公共子序列变为求最大
>
> 公共序列ASCll和。

```java
public int minimumDeleteSum(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    int sum1 = 0; int sum2 = 0;
    for(int i=0;i<m;i++){
        sum1 = sum1+Integer.valueOf(s1.charAt(i));
    }
    for(int j=0;j<n;j++){
        sum2 = sum2+Integer.valueOf(s2.charAt(j));
    }
        int[][] dp =new int[m+1][n+1];
        for(int i =1;i <= m; i++){
            for(int j = 1; j<=n; j++){
                if(s1.charAt(i-1) == s2.charAt(j-1)){
                     dp[i][j] = dp[i-1][j-1] + Integer.valueOf(s1.charAt(i-1));
                }else{
                    dp[i][j]= Math.max(dp[i-1][j],dp[i][j-1]);
                }
            
            }
        }
        return sum1+sum2-2*dp[m][n];
}
```

