---
title: 算法-动态规划
date: 2022-03-01
categories:
 - 算法
tags:
 - leetcode
 - 动态规划（算法）
sidebar: 'auto'
---



### [零钱兑换](https://leetcode-cn.com/problems/coin-change/)（经典）

![image-20220315173540980](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220315173540980.png) 

> 思路：最优子结构问题，递归 和 动态规划(具有**重叠子问题**)
>
> ![image-20220315180058993](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220315180058993.png) 
>
> 1、**确定 base case**，显然目标金额 `amount` 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。
>
> 2、**确定「状态」，也就是原问题和子问题中会变化的变量**。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 `amount`。
>
> 3、**确定「选择」，也就是导致「状态」产生变化的行为**。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。
>
> 4、**明确 `dp` 函数/数组的定义**：输入一个目标金额 `n`，返回凑出目标金额 `n` 的最少硬币数量。

![image-20220315173900272](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220315173900272.png) 

```java 
// 递归写法
  // 带备忘录的递归
    int[] memo;

    public int coinChange(int[] coins, int amount) {
        memo  = new int[amount + 1];
        // dp数组全都初始化为特殊值
        Arrays.fill(memo, -666);
        return dp(coins, amount);
    }

    int dp(int[] coins, int amount){
        if(amount == 0) return 0;
        if(amount < 0) return -1;
        //查看备忘录，防止重复计算
        if(memo[amount] != -666) return memo[amount];

        int res = Integer.MAX_VALUE;
        for(int coin : coins){
            //计算子问题的结果
            int subProblem = dp(coins, amount - coin);
            // 子问题无解则跳过
            if (subProblem == -1) continue;
            // 在子问题中选择最优解，然后加1
            res = Math.min(res, subProblem+1);
        }
        //把计算结果存入备忘录
        memo[amount] = (res == Integer.MAX_VALUE) ? -1 : res;
        return memo[amount];
    }
```

![image-20220315180118099](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220315180118099.png) 

```java
    public int coinChange(int[] coins, int amount) {
        // 定义和初始化dp 数组
        int[] dp = new int[amount+1];
        Arrays.fill(dp, amount+1);//只要给一个不可能的值就行
        
        // base case
        dp[0] = 0;
        //外层遍历所有状态的所有可能值
        for(int i=0; i < dp.length; i++){
            // 内层 for 循环在求所有选择的最小值
            for(coin:coins){
                if (i-coins<0){ //子问题无解跳过
                    continue;
                }
                dp[i] = Math.min(dp[i],1+dp[i-coin]);
            }
        }
        return (dp[amount] == amount + 1) ? -1 : dp[amount];
    }
```





