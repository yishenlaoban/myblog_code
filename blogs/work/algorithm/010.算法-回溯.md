---
title: 算法-回溯
date: 2022-03-24
categories:
 - 算法
tags:
 - leetcode
 - 回溯
sidebar: 'auto'
---



### [ 划分为k个相等的子集](https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/) （组合）

![image-20220324195719056](https://img2022.cnblogs.com/blog/2346254/202203/2346254-20220324195718347-118541095.png) 

> 思路：排列，组合题----->回溯
>
> 想法1：以数字为关注点
>
> 递归遍历每一个数字，在每一层 递归中遍历每个集合装入当前nums[index], 能装入就带着这个结果进入下一个递归；当前递归结束条件：index==k；

```java
public boolean canPartitionKSubsets(int[] nums, int k) {
         // 排除一些基本情况
         if(k > nums.length) return false;
         int sum = 0;
         for(int num : nums) sum += num;
         if(sum%k != 0) return false;
     
         //k个集合，记录每个桶装的数字之和
         int[] bucket = new int[k];
         //计算理论上每个集合的目标值
         int target = sum/k;
         return backtrack(nums,0,bucket,target);
    }

    boolean backtrack(int[] nums, int index, int[] bucket, int target){
        //遍历到了最后一个数
        if(index == nums.length){
            //检查所有桶的数字之和是否都是目标值
            for(int i =0;i<bucket.length;i++){
                if(bucket[i]!=target){
                    return false;
                }
            }
            return true;
        }

        //穷举每个桶，nums[index]能装进去就进行下一步遍历
        for(int i=0; i<bucket.length;i++){
            //不能装下这个数跳过
            if(bucket[i]+nums[index] > target){
                continue;   
            }

            //将nums[index] 装入这个bucket[i] 
            bucket[i] += nums[index];
            // 递归穷举下一个数字；（类后序）回溯的体现
            if(backtrack(nums, index+1, bucket, target)) {
                return true;
            }
            //撤销选择；给bucket[i]在后面的bucket[n]的递归中留下机会
            bucket[i] -= nums[index];
        }

        return false;//遍历完了还没有结果则为false
    }
```



> 思路2： 以桶为关注点
>
> 将每个子集看作是一个桶，有多少个子集就有多少个桶，然后遍历nums，向桶中添加元素
>
> * 如果循环完nums都无法装满当前的桶，证明无法分成k个总和相等的非空子集，返回false
> * 循环时做减枝
>
> ​                 1. 如果当前的数字已被使用，跳过
>
> ​                 2.如果sum+nums[i]>target即当前桶装不下，跳过
>
> * 然后将nums[i]装入桶，继续递归第i+1个数字是否能装入当前桶
> * 如果当前桶装满了，递归装下一个 backtrack(k-1,0,target,0,nums,flag);
> * 直到所有桶都被装满 返回true
>
> ```java
> public boolean backtrack(int k,int sum,int target,int start,int[] nums,boolean[] flag)
> ```
>
> k表示桶个数，sum表示当前桶的值，target表示桶装满的值，start表示从数组的哪个位置开始选择数字装入桶，flag记录数字是否已被使用

```java
   public boolean canPartitionKSubsets(int[] nums, int k) {
        int sum = Arrays.stream(nums).sum();
        if(sum%k != 0){
            return false;
        }
        //每个集合的目标值
        int target = sum/k;
        boolean[] flag = new boolean[nums.length];//标注被放入集合的数字
        return backtrack(k,0,target,0,nums,flag);
    }

    boolean backtrack(int k,int sum,int target,int start,int[] nums,boolean[] flag){
        //所有桶被装满了
        if(k==0){
            return true;
        }
        //这个桶装满了下一个
        if(sum==target){
            return backtrack(k-1,0,target,0,nums,flag);
        }
        for(int i=start;i<nums.length;i++){
            //数组已被使用过，跳过
            if(flag[i]){
                continue;
            }
            //当前桶装不下
            if(sum+nums[i]>target){
                continue;
            }
            //选择nums[i] 装入桶中
            sum += nums[i];
            flag[i] = true;
            //递归穷举下一个数字是否能装入当前桶中
            if(backtrack(k,sum,target,i+1,nums,flag)){
                return true;
            }

            //撤销
            sum -= nums[i];
        }
        //穷举所有的数字并没有得到结果
        return false;
    }
```



