---
title: 算法-剑指offer
date: 2022-03-31
categories:
 - 算法
tags:
 - leetcode
 - 刷题
 - 剑指offer
sidebar: 'auto'
---



### [用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)（栈）

![image-20220331171359167](http://yishenlaoban-img.test.upcdn.net/image_my/image-20220331171359167.png) 

> 思路：
>
> 栈的结构：先进后出
>
> 队列结构：先进先出
>
> 这里我们要做的是用两个栈辅助实现，一个栈input 用于加入队列，一个栈output输入队列；**要注意的是我们在出队列的时候先查看output队列是否为空，如果不为空则直接pop(), 为空则先从input转移到output再pop**

```java
class CQueue {
   
    Stack<Integer> input = null;
    Stack<Integer> output = null;
   
    public CQueue() {
         input = new Stack<>();
         output= new Stack<>();
    }
    
    public void appendTail(int value) {
        this.input.push(value);
    }
    
    public int deleteHead() {
        if(this.output.isEmpty()){
            if(this.input.isEmpty()){
              return -1;
            }
            while(!this.input.isEmpty()){
               this.output.push(this.input.pop());
            }
        }
        return this.output.pop();
    }
}
```



### [包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/) (栈)

![image-20220331171915194](http://yishenlaoban-img.test.upcdn.net/image_my/image-20220331171915194.png) 

> * **数据栈 A**： 栈 A 用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。
>
> * **辅助栈 B** ： 栈 B 中存储栈 A 中所有 非严格降序 的元素，则栈 A 中的最小元素始终对应栈 B 的栈顶元素，即 min() 函数只需返回栈 B 的栈顶元素即可。
>   因此，只需设法维护好 栈 B 的元素，使其保持非严格降序，即可实现 min() 函数的 O(1) 复杂度。
>
>   ![image-20220331172041459](http://yishenlaoban-img.test.upcdn.net/image_my/image-20220331172041459.png) 

```java
class MinStack {

    /** initialize your data structure here. */

    Stack<Integer> stack = null;
    Stack<Integer> min_stack = null;
    public MinStack() {
        stack  = new Stack<>();
        min_stack = new Stack<>();
    }
    
    public void push(int x) {
        if(min_stack.isEmpty()||min_stack.peek()>=x) this.min_stack.push(x); //保持min_stack的严格降序
        stack.push(x);
    }
    
    public void pop() {
       Integer temp = stack.pop();
       if(min_stack.peek().equals(temp)){ //如果pop出去的是当前最小值，min_stack也要做相应的pop
           min_stack.pop();
       }
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int min() {
        return min_stack.peek();
    }
}
```



### [从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)  (栈 ，链表)

![image-20220331172425004](http://yishenlaoban-img.test.upcdn.net/image_my/image-20220331172425004.png) 

> 思路：
>
> 这里有两种写法
>
> 链表的前序，后序遍历：前序：确定数组长度，后序：数组添加元素
>
> 栈：遍历一遍链表把节点的值压入栈中，然后从栈中输入到数组

```java
//方案1：
class Solution {
    int len = 0;
    int i =0;
    int[] nums = null;
    public int[] reversePrint(ListNode head) {
        reback(head);
        return nums;
    }
    //前序：确定数组长度
    //后序：数组添加元素
    public void reback(ListNode node){
         if(node==null){
             nums =  new int[len];
             return;
         }
         len++;
         reback(node.next);
         nums[i++] = node.val;
    }
}

//方案2：
class Solution {
    public int[] reversePrint(ListNode head) {
        Stack<ListNode> stack = new Stack<ListNode>();
        ListNode temp = head;
        while (temp != null) {
            stack.push(temp);
            temp = temp.next;
        }
        int size = stack.size();
        int[] print = new int[size];
        for (int i = 0; i < size; i++) {
            print[i] = stack.pop().val;
        }
        return print;
    }
}
```



### [反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)（后序遍历）

> 思路： 递归函数：
>
> 后序遍历到最后，返回尾结点，当前的后序处理是把当前节点的方向转过来

```java
 public ListNode reverseList(ListNode head) {
     if(head==null){
         return null;
     }
     return retrack(head);    
    }
    public ListNode retrack(ListNode node){
        if(node.next==null){
            return node;
        }
        ListNode last = retrack(node.next);
        node.next.next = node;
        node.next = null;
        return last;
    }
```





### [复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/) (后序)

![image-20220331211348434](http://yishenlaoban-img.test.upcdn.net/image_my/image-20220331211348434.png) 

> 思路：
>
>  递归函数定义：new 一个节点复制 old节点的next 和 random，并返回新节点。
>
> * 前序遍历所有的节点，并把**节点存储到map<Node,Node>， 这里的key为旧节点，value为新节点**，这里的处理是为了后面random 找到之前的节点
> * 后序遍历，给新节点的next，和random 赋值

```java
    Map<Node,Node> map = new HashMap<>();

    public Node copyRandomList(Node head) {
        if(head==null){
            return null;
        }
        return copy(head);
    }

    public Node copy(Node node){
        if(node==null){
            return null;
        }
        //前序遍历old节点，并new新节点
        Node temp = new Node(node.val);
        map.put(node,temp);//新节点存入map,random赋值使用
        
        //后序遍历next,random 赋值
        temp.next = copy(node.next);
        Node node_random = node.random;
        if(node_random==null){
            temp.random = null;
        }else{
            temp.random = map.get(node_random);
        }
        return temp; //返回new节点
    }
```

