---
title: 算法-数组
date: 2022-01-09
categories:
 - 算法
tags:
 - leetcode
 - 数组
sidebar: 'auto'
---

### 移动零

![image-20220301154429833](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220301154429833.png) 

> 思路1：使用双指针
>
> 两个指针并行走：
>
>   如果left一直没有遇到 0，right和left交换本身，指针继续走；
>
>   如果遇到0，right继续走，left停止，直到right遇到非零，交换值后left继续走；

```java
 public void moveZeroes(int[] nums) {
        int left=0;int right =0;
        while(right < nums.length){
            if(nums[right]!=0){
                int temp = nums[right];
                nums[right] = nums[left];
                nums[left] =temp;

                left++;
            }
            right++;
        }
    }
```

> 思路2：一个数组用于记录nums;
>
> 遍历数组，把所有的非零数字重新按顺序赋值给nums;
>
> nums剩余的位置全填0；

```java
   public void moveZeroes(int[] nums) {
         
         int[] sum = nums;
         int len = nums.length;
         int j=0;
         for(int i=0;i<len;i++){
           if(sum[i]!=0){
               nums[j] = sum[i];
               j++; 
           }
         }

         for(int k = j; k<len;k++){
             nums[k] = 0;
         }

    }
```



### 区域和检索--数组不可变

> **前缀和**：在计算数据某个区间的和，我们可以用到前缀和；我们只要遍历一次数组把用一个新的数组preSum[]去记录它到第一个数的和，如果后面要计算m->n 的区间和，就直接preSum[n] - preSum[m]; 

![image-20220303112920909](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220303112920909.png)

![image-20220303113739644](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220303113739644.png) 

 ```java
 class NumArray {
     // 前缀和数组
     private int[] preSum;
 
     /* 输入一个数组，构造前缀和 */
     public NumArray(int[] nums) {
         // preSum[0] = 0，便于计算累加和
         preSum = new int[nums.length + 1];
         // 计算 nums 的累加和
         for (int i = 1; i < preSum.length; i++) {
             preSum[i] = preSum[i - 1] + nums[i - 1];
         }
     }
     
     /* 查询闭区间 [left, right] 的累加和 */
     public int sumRange(int left, int right) {
         return preSum[right + 1] - preSum[left];
     }
 }
 ```



### 二维区间和（前缀和变式）

![image-20220303161902380](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220303161902380.png) 

> 思路：在这里我们可以类比于前缀和的，构造一个数组SumMatrix,记录所有点NumMatrix[n] [m]到初始点NumMatrix[0] [0] 的矩阵元素和，把它当作一个表来查，求某一块矩阵和就用表里的数据来计算

![image-20220303162846889](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220303162846889.png) 

```java
class NumMatrix {
      // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和
    int[][] SumMatrix;
    public NumMatrix(int[][] matrix) {
       SumMatrix = new int[matrix.length+1][matrix[0].length+1];
       int row=matrix.length,col=matrix[0].length;
       for(int i = 1;i<=row;i++){
           for(int j=1;j<=col;j++){
               // 计算每个矩阵 [0, 0, i, j] 的元素和
               SumMatrix[i][j] = SumMatrix[i-1][j]+SumMatrix[i][j-1]-SumMatrix[i-1][j-1]+matrix[i-1][j-1];
           }
       }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) { //注意SumMatrix是从[1][1]开始的；
        return SumMatrix[row2+1][col2+1] - (SumMatrix[row2+1][col1] + SumMatrix[row1][col2+1] - SumMatrix[row1][col1]);
    }
}
```



### 和为 K 的子数组

![image-20220303195205203](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220303195205203.png) 

> 这个题的思路：一个前缀和，常规的算法可以简单实现但是就时间复杂度高O(n^2)`这里代码就不写了`，这里可以用一个**hash表**记录出现过的前缀和中与当前前缀和num[0...i] 的差是满足条件的来计算出现的子数组次数,时间复杂度O(n)

```java
 public int subarraySum(int[] nums, int k) {
        int len = nums.length;
        // map:记录前缀和出现的次数
        HashMap<Integer,Integer> sums = new HashMap<>();
        sums.put(0,1);

        int res = 0, sum0_i = 0;
        for(int i = 0; i < len;i++){
            sum0_i = sum0_i + nums[i];
            //找前面是否出现过 num[0...j] 使式子成立，就是说nums[j...i] = k存在；
            int sum0_j = sum0_i - k; 
            if(sums.containsKey(sum0_j)) res += sums.get(sum0_j);
            // 把前缀和 nums[0...i] 加入并记录出现的次数
            sums.put(sum0_i, sums.getOrDefault(sum0_i,0)+1);
        }
        
        return res;
    }
```

