---
title: 算法-数组
date: 2022-01-09
categories:
 - 算法
tags:
 - leetcode
 - 数组
sidebar: 'auto'
---

### 移动零

![image-20220301154429833](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220301154429833.png) 

> 思路1：使用双指针
>
> 两个指针并行走：
>
>   如果left一直没有遇到 0，right和left交换本身，指针继续走；
>
>   如果遇到0，right继续走，left停止，直到right遇到非零，交换值后left继续走；

```java
 public void moveZeroes(int[] nums) {
        int left=0;int right =0;
        while(right < nums.length){
            if(nums[right]!=0){
                int temp = nums[right];
                nums[right] = nums[left];
                nums[left] =temp;

                left++;
            }
            right++;
        }
    }
```

> 思路2：一个数组用于记录nums;
>
> 遍历数组，把所有的非零数字重新按顺序赋值给nums;
>
> nums剩余的位置全填0；

```java
   public void moveZeroes(int[] nums) {
         
         int[] sum = nums;
         int len = nums.length;
         int j=0;
         for(int i=0;i<len;i++){
           if(sum[i]!=0){
               nums[j] = sum[i];
               j++; 
           }
         }

         for(int k = j; k<len;k++){
             nums[k] = 0;
         }

    }
```



### 区域和检索--数组不可变

> **前缀和**：在计算数据某个区间的和，我们可以用到前缀和；我们只要遍历一次数组把用一个新的数组preSum[]去记录它到第一个数的和，如果后面要计算m->n 的区间和，就直接preSum[n] - preSum[m]; 

![image-20220303112920909](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220303112920909.png)

![image-20220303113739644](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220303113739644.png) 

 ```java
 class NumArray {
     // 前缀和数组
     private int[] preSum;
 
     /* 输入一个数组，构造前缀和 */
     public NumArray(int[] nums) {
         // preSum[0] = 0，便于计算累加和
         preSum = new int[nums.length + 1];
         // 计算 nums 的累加和
         for (int i = 1; i < preSum.length; i++) {
             preSum[i] = preSum[i - 1] + nums[i - 1];
         }
     }
     
     /* 查询闭区间 [left, right] 的累加和 */
     public int sumRange(int left, int right) {
         return preSum[right + 1] - preSum[left];
     }
 }
 ```



### 二维区间和（前缀和变式）

![image-20220303161902380](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220303161902380.png) 

> 思路：在这里我们可以类比于前缀和的，构造一个数组SumMatrix,记录所有点NumMatrix[n] [m]到初始点NumMatrix[0] [0] 的矩阵元素和，把它当作一个表来查，求某一块矩阵和就用表里的数据来计算

![image-20220303162846889](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220303162846889.png) 

```java
class NumMatrix {
      // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和
    int[][] SumMatrix;
    public NumMatrix(int[][] matrix) {
       SumMatrix = new int[matrix.length+1][matrix[0].length+1];
       int row=matrix.length,col=matrix[0].length;
       for(int i = 1;i<=row;i++){
           for(int j=1;j<=col;j++){
               // 计算每个矩阵 [0, 0, i, j] 的元素和
               SumMatrix[i][j] = SumMatrix[i-1][j]+SumMatrix[i][j-1]-SumMatrix[i-1][j-1]+matrix[i-1][j-1];
           }
       }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) { //注意SumMatrix是从[1][1]开始的；
        return SumMatrix[row2+1][col2+1] - (SumMatrix[row2+1][col1] + SumMatrix[row1][col2+1] - SumMatrix[row1][col1]);
    }
}
```



### 和为 K 的子数组

![image-20220303195205203](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220303195205203.png) 

> 这个题的思路：一个前缀和，常规的算法可以简单实现但是就时间复杂度高O(n^2)`这里代码就不写了`，这里可以用一个**hash表**记录出现过的前缀和中与当前前缀和num[0...i] 的差是满足条件的来计算出现的子数组次数,时间复杂度O(n)

```java
 public int subarraySum(int[] nums, int k) {
        int len = nums.length;
        // map:记录前缀和出现的次数
        HashMap<Integer,Integer> sums = new HashMap<>();
        sums.put(0,1);

        int res = 0, sum0_i = 0;
        for(int i = 0; i < len;i++){
            sum0_i = sum0_i + nums[i];
            //找前面是否出现过 num[0...j] 使式子成立，就是说nums[j...i] = k存在；
            int sum0_j = sum0_i - k; 
            if(sums.containsKey(sum0_j)) res += sums.get(sum0_j);
            // 把前缀和 nums[0...i] 加入并记录出现的次数
            sums.put(sum0_i, sums.getOrDefault(sum0_i,0)+1);
        }
        
        return res;
    }
```



### 差分数组

**特点：差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减**。

比如说，我给你输入一个数组 `nums`，然后又要求给区间 `nums[2..6]` 全部加 1，再给 `nums[3..9]` 全部减 3，再给 `nums[0..4]` 全部加 2，再给…

一通操作猛如虎，然后问你，最后 `nums` 数组的值是什么？

常规的思路很容易，你让我给区间 `nums[i..j]` 加上 `val`，那我就一个 for 循环给它们都加上呗，还能咋样？这种思路的时间复杂度是 O(N)，由于这个场景下对 `nums` 的修改非常频繁，所以效率会很低下。

这里就需要差分数组的技巧，类似前缀和技巧构造的 `prefix` 数组，我们先对 `nums` 数组构造一个 `diff` 差分数组，**`diff[i]` 就是 `nums[i]` 和 `nums[i-1]` 之差**：

```java
int[] diff = new int[nums.length];
//构造差分数组
diff[0] = num[0];
for(int i =1;i<nums.length;i++){
    diff[i] = nums[i] - nums[i-1];
}
```

![image-20220304162921777](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220304162921777.png) 

通过这个 `diff` 差分数组是可以反推出原始数组 `nums` 的，代码逻辑如下：

```java
int[] res = new int[diff.length];
res[0]  = diff[0];
for(int i=1;i<diff.length;i++){
    res[i] = res[i-1]+diff[i];
}
```

**这样构造差分数组 `diff`，就可以快速进行区间增减的操作**，如果你想对区间 `nums[i..j]` 的元素全部加 3，那么只需要让 `diff[i] += 3`，然后再让 `diff[j+1] -= 3` 即可：

![image-20220304163204473](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220304163204473.png) 

**原理很简单，回想 `diff` 数组反推 `nums` 数组的过程，`diff[i] += 3` 意味着给 `nums[i..]` 所有的元素都加了 3，然后 `diff[j+1] -= 3` 又意味着对于 `nums[j+1..]` 所有元素再减 3，那综合起来，是不是就是对 `nums[i..j]` 中的所有元素都加 3 了**？

只要花费 O(1) 的时间修改 `diff` 数组，就相当于给 `nums` 的整个区间做了修改。多次修改 `diff`，然后通过 `diff` 数组反推，即可得到 `nums` 修改后的结果。

现在我们把差分数组抽象成一个类，包含 `increment` 方法和 `result` 方法：

```java
// 差分数组工具类
class Difference {
    // 差分数组
    private int[] diff;
    
    /* 输入一个初始数组，区间操作将在这个数组上进行 */
    public Difference(int[] nums) {
        assert nums.length > 0;
        diff = new int[nums.length];
        // 根据初始数组构造差分数组
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }

    /* 给闭区间 [i,j] 增加 val（可以是负数）*/
    public void increment(int i, int j, int val) {
        diff[i] += val;
        if (j + 1 < diff.length) {
            diff[j + 1] -= val;
        }
    }

    /* 返回结果数组 */
    public int[] result() {
        int[] res = new int[diff.length];
        // 根据差分数组构造结果数组
        res[0] = diff[0];
        for (int i = 1; i < diff.length; i++) {
            res[i] = res[i - 1] + diff[i];
        }
        return res;
    }
}
```



###  航班预订统计(差分变式)

![image-20220304170058261](https://gitee.com/yishenlaoban/git-typore/raw/master/image_my/image-20220304170058261.png) 

> 思路：很简单啦，就是一个初始差分数组为0，通过条件重构差分，再通过差分数组构造原数组；
>
> 这里注意起始index是为 1；

```java
class Solution {
    int[] diff; //差分数组
    public int[] corpFlightBookings(int[][] bookings, int n) {
         diff = new int[n]; //初始化差分数组，因为原数组没有，所有差分数组的所有值为0
         int len = bookings.length;
         for(int i=0;i<len;i++){
             getDiff(bookings[i][0]-1,bookings[i][1]-1,bookings[i][2]); //调整差分数组
         }
         return getResult(n); //利用差分数组重构原数组；
         
    }

    public void getDiff(int start,int end,int num){
        diff[start] += num;
        if(end+1 < diff.length){
            diff[end+1] -= num;
        }
    }

    public int[] getResult(int len){
        int[] result = new int[len];

        result[0] = diff[0];
        for(int i =1;i<len;i++){
            result[i] = result[i-1]+diff[i];
        }
        return result;
    }

}
```



