---
title: 面试-Java
date: 2022-01-09
categories:
 - 面试
tags:
 - Java面试
sidebar: 'auto'
---

<img src="https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220227163139319.png" alt="image-20220227163139319"  />	

### 面向对象

什么是面向对象？

对比面向过程，是两种不同的处理问题的角度

面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做

什么;

`面向对象`

**封装**：封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项

内部细节对外部调用透明，外部调用无需修改或者关心内部实现

1、javabean的属性私有，提供getset对外访问，因为属性的赋值或者获取逻辑只能由javabean本身决

定。而不能由外部胡乱修改

```java
private String name;
public void setName(String name){
    this.name = "tuling_"+name;
}
该name有自己的命名规则，明显不能由外部直接赋值
```

2、orm框架

操作数据库，我们不需要关心链接是如何建立的、sql是如何执行的，只需要引入mybatis，调方法即可

**继承**：继承基类的方法，并做出自己的改变和/或扩展

子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的

**多态**：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。

继承，方法重写，父类引用指向子类对象

```java
父类类型 变量名 = new 子类对象 ; 

变量名.方法名();
```

`无法调用子类特有的功能	`



### **JDK JRE JVM 区别与联系**

JDK：Java Develpment Kit java 开发工具

JRE：Java Runtime Environment java运行时环境

JVM：java Virtual Machine java 虚拟机

![image-20220227164343230](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220227164343230.png) 

**工作流程**：

​       JDK是 java 程序员使用的编程工具，写好的java程序，通过java工具包里的`javac`进行编译成`.class`文件（字节码文件），这个文件可以在`windows, linux`机器的`JVM`调用lib类库解释为机器码运行。



### "=="和equals()区别，以及为什么重写了equals要重写**hashCode()**?

**"=="**  : 比较的是`栈中的值`；

*  基本数据类型：就存在栈中，所以比较的是变量值；

* 引用数据类型（类，接口，数组，String）:

​          当他们用 ( == ) 比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为`true`，否则比较后结果为`false`。



**equals** :

​    以为以上的缺陷，引用数据要用equals进行比较，如果我们不重写equals，这里的类都是继承的Object类，而Object类中的equals 方法的实现 也是 `this == object`,比较的还是内存地址；

**重写equals目的是为了：比较对象的值是否相等；**

例如：

```java
public Class User{
    int id;
    int age;
    
    @Override
    public boolean equals(User user){
        return (this.id==user.id && this.age==user.age);
    }
}
```

这样比较的就是对象里每个元素是否相等，从而实现对象是否内容相等；

**String 的equals 实现**：比较每个字符是否相等

```java
public boolean equals(Object anObject) { 
    if (this == anObject) { return true; }
    if (anObject instanceof String) { 
        String anotherString = (String)anObject; 
        int n = value.length; 
        if (n == anotherString.value.length) { 
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++; 
            }
            return true;
        } 
    }
    return false;
}
```



**hashCode:**

​       hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是

确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有

hashCode() 函数。

​       散列表存储的是键值对(key-value)，它的特点是：`能根据“键”快速的检索出对应的“值”`。这其中就利用

到了散列码！（可以快速找到所需要的对象）

​        在Java中,我们一般是在hashSet,hashMap这些集合时使用hashCode，每个对象都可以调⽤⾃⼰的hashCode()⽅法得到⾃⼰的哈希值(hashCode),

然而，如果使用本来的hashCode(),拿到`对象的地址`进行计算得到hash码，这样的话就会有equals结果相同却hashCode不同的出现，hashSet,hashMap使用就没有意义；

hashCode()重写的目的：

​         1、保证equals的结果相同的话计算的hashCode也要相同；

​        `当然可能出现不同的对象有相同的hashCode(hash冲突)`

        ```java
 @Override
    public int hashCode() {
        int result = Objects.hash(id, age); //用每个元素去做hash
        result = 31 * result + Arrays.hashCode(dynamicTags);
        return result;
    }
        ```

​         2、对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，重写hashCode()之后，相同的hash就是内容相同，我们就没有必要去比较equals了；如果不同，再去比较equals,，这样既能大大提高了效率也保证了对比的绝对正确性！

这里可以在重写equals里调用hashCode()

```java
public Class User{
    int id;
    int age;
    
    @Override
    public boolean equals(User user){
        if(this.hashCode(user)){ //先比较hash
            return true;
        }else{
             return (this.id==user.id && this.age==user.age);
        }
    }
}
```





### final 和 static 关键字修饰

**final：**

最终的

* 修饰类：表示类不可被继承

* 修饰方法：表示方法不可被子类覆盖，但是可以重载

*  修饰变量：表示变量一旦被赋值就不可以更改它的值。（形参列表的个数和类型不一样）

（1）修饰成员变量

* 如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。

* 如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。

（2）修饰局部变量

系统不会为局部变量进行初始化，局部变量必须由程序员显示初始化。因此使用final修饰局部变量时，

即可以在定义时指定默认值（后面的代码不能对变量再赋值），也可以不指定默认值，而在后面的代码

中对final变量赋初值（仅一次）

```java
public class FinalVar { 
    final static int a = 0;
    //再声明的时候就需要赋值 或者静态代码块赋值 
    /** 
    static{ 
      a = 0; 
    }*/
    final int b = 0;
    //再声明的时候就需要赋值 或者代码块中赋值 或者构造器赋值
    /*{ b = 0; }*/ 
    public static void main(String[] args) { 
         final int localA; 
        //局部变量只声明没有初始化，不会报错,与final无关。
         localA = 0;
        //在使用之前一定要赋值 
        //localA = 1;但是不允许第二次赋值 
    } 
}
```

（3）修饰基本类型数据和引用类型数据

* 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；

* 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。**但是引用的值是可变**

**的**。 (`注意：基本类型包装类和String 是final 修饰的，但是修饰的是对象的值，所以值是不可变的`), 这里是引用变量被修饰，对象的值可以变；

```java
public class FinalReferenceTest{ 
    public static void main(){ 
        final int[] iArr={1,2,3,4}; 
        iArr[2]=-3;//合法 
        iArr=null;//非法，对iArr不能重新赋值 
        
        final Person p = new Person(25);
        p.setAge(24);//合法 
        p=null;//非法 
    } 
}
```

**为什么局部内部类和匿名内部类只能访问局部final变量？**

编译之后会生成两个class文件，Test.class Test1.class

```java
public class Test {
    public static void main(String[] args) { }
    //局部final变量a,b
    public void test(final int b) {//jdk8在这里做了优化,不用写,语法糖，但实际上也是有的，也不能修改 
        final int a = 10; //匿名内部类
        new Thread(){ 
            public void run() { 
                System.out.println(a);
                System.out.println(b);
            }; 
        }.start(); 
    } 
}

class OutClass {
    private int age = 12;
    public void outPrint(final int x) {
        class InClass { 
            public void InPrint() { 
                System.out.println(x);
                System.out.println(age);
                } 
        }
        new InClass().InPrint(); 
    } 
}
```

​        首先需要知道的一点是: `内部类和外部类是处于同一个级别的`，内部类不会因为定义在方法中就会随着

方法的执行完毕就被销毁。

​        这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有没有人再引用它时，才会死亡)。

​        这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，`实际访问的是局部变量的"copy"`。这样就好像延长了局部变量的生命周期;

​       将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修

改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。这实际上也是一种妥协。`使得局部变量与内部类内建立的拷贝保持一致`。

**static （待定）**



### **Integer**

所有整型包装类对象之间值的比较，全部使用equals方法比较。

​        对于Integer var=?在-128至127之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。



### **String、StringBuffer,StringBuilder**

String是final修饰的，不可变，每次操作都会产生新的String对象

StringBuffer和StringBuilder都是在原对象上操作

StringBuffer是线程安全的，StringBuilder线程不安全的

StringBuffer方法都是synchronized修饰的

`性能：StringBuilder > StringBuffer > String`



场景：经常需要改变字符串内容时使用后面两个

优先使用StringBuilder，多线程使用共享变量时使用StringBuffer



### **重载和重写的区别**

**重写**:

重写（Override）是父类与子类之间多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Override)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。

**重载：**

重载（Overload）是一个类中多态性的一种表现。如果在一个类中定义了多个同名的方法，它们参数列表不同，则称为方法的重载(Overload)

**区别：**重载实现于一个类中;重写实现于子类中。

`重载(Overload)`：是一个类中多态性的一种表现，指同一个类中不同的函数使用**相同的函数名**，但是**函数的参数个数或类型不同**。可以有**不同的返回类型**;可以有不同的访问修饰符;可以抛出不同的异常。调用的时候根据函数的参数来区别不同的函数。

`重写（Override):` 是父类与子类之间的多态性，是**子类对父类函数的重新实现**。**函数名和参数与父类一样**，子类与父类**函数体内容不一样**。子类**返回的类型**必须与父类保持一致；子类方法访问修饰符的限制一定要大于父类方法的访问修饰（public>protected>default>private）；子类重写方法一定不能抛出新的检查异常或者比被父类方法申明更加宽泛的检查型异常。**如果父类方法访问修饰符为private则子类就不能重写该方**

**法**

```java
    public int add(int a,String b) 
    public String add(int a,String b) //编译报错
```



### **抽象类和接口的区别**

* 抽象类可以有普通的成员方法，接口中只能存在public abstract 方法;
* 抽象类的成员变量有很多种，而接口的成员变量必须用 public static final 修饰（常量）；
* 抽象类只能继承一个，接口可以实现多个

​    **接口的设计目的**，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有

什么行为），也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，

但不对如何实现行为进行限制。

​    **抽象类的设计目的**，是代码复用。当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行

为的实现方式一致时（A的非真子集，记为B），可以让这些类都派生于一个抽象类。在这个抽象类中实

现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己

实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用到A-B时，无法执

行）。

​      抽象类是对类本质的抽象，表达的是 is a 的关系，比如： BMW is a Car 。抽象类包含并实现子类的通

用特性，将子类存在差异化的特性进行抽象，交由子类去实现。

而接口是对行为的抽象，表达的是 like a 的关系。比如： Bird like a Aircraft （像飞行器一样可以

飞），但其本质上 is a Bird 。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、

是如何实现的，接口并不关心。

**使用场景：**当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。

抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也

是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功

能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计

阶段会降低难度



### 集合

#### List和Set的区别

List：有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出

所有元素，在逐一遍历，还可以使用get(int index)获取指定下标的元素

Set：无序，不可重复，最多允许有一个Null元素对象，取元素时只能用Iterator接口取得所有元

素，在逐一遍历各个元素



#### ArrayList和LinkedList区别

**ArrayList：**基于动态数组，连续内存存储，适合下标访问（随机访问），扩容机制：因为数组长度固

定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会

涉及到元素的移动（往后复制一份，插入新元素），使用**尾插法并指定初始容量可以极大提升性能、甚**

**至超过linkedList（需要创建大量的node对象）**

**LinkedList：**基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询：需要逐

一遍历

遍历LinkedList必须使用iterator**不能使用for循环**，因为每次for循环体内通过get(i)取得某一元素时都需

要对list重新进行遍历(时间复杂度**O(n^2)**)，性能消耗极大。

另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结

果为空时会遍历整个列表。



#### HashMap和HashTable有什么区别？其底层实现是什么？

区别 ： 

（1）HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；

（2）HashMap允许key和value为null，而HashTable不允许

`HashTable的性能太低，现在不怎么用了，一般都用ConcurrentHashMap代替`

2.底层实现：数组+链表实现

jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在

* 计算key的hash值，二次hash然后对数组长度取模，对应到数组下标，

* 如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组，

* 如果产生hash冲突，先进行equal比较，相同则取代该元素，不同，则判断链表高度插入链表，链

 表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表

* key为null，存在下标0的位置

**数组扩容**



#### ConcurrentHashMap原理，jdk7和jdk8版本的区别？

`jdk7`：数据结构：ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每个

HashEntry又是一个链表结构

元素查询：二次hash，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部

锁：Segment分段锁（`锁住一部分的Key,粒度比HashTable更新，效率高`） Segment继承了ReentrantLock，锁定操作的Segment，其他的Segment不受影响，并发度为segment个数，可以通过构造函数指定，数组扩容不会影响其他的segment

**get方法无需加锁，volatile保证**

`jdk8：`

数据结构：synchronized+CAS+Node+红黑树，Node的val和next都用volatile修饰，保证可见性

**查找，替换，赋值操作都使用CAS**, 乐观锁(自旋锁机制)性能高；在扩容和出现哈希冲突的时候，CAS处理不了是用**synchroniaed** 来处理

锁：**锁链表的head节点**，不影响其他元素的读写，**锁粒度更细，效率更高**，扩容时，阻塞所有的读写

操作、并发扩容

读操作无锁：

Node的val和next使用volatile修饰，读写线程对该变量互相可见

数组用volatile修饰，保证扩容时被读线程感知



#### List

##### ArrayList扩容

> 新容量为原数组长度的1.5倍，如果扩容后的容量依然小于需要的容量，就将需要容量作为数组的长度。
>
> 然后将原数组元素拷贝到新的数组并返回

```java
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```

 

##### ArrayList在jdk7、8的不同

1. jdk7

   - ArrayList list = new ArrayList()；//底层elementData数组初始大小为10
   - 执行add()时，如果此次的添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中

2. jdk8

   > 底层elementData初始化为{}，并没有初始化为长度10的数组，而是第一次调用add的时候，底层才创建了长度为10的数组，并将数据加入到数组。后续的添加和扩容操作与JDK7无异

3. 总结：

   > JDK7中的ArrayList的对象创建类似于单例模式中的饿汉式，而JDK8中的类似于懒汉式，延迟了数组的创建，节省了内存



##### HashSet

> 底层也是数组(是一个HashMap)，初始容量为16，当如果使用率超过0.75，(16*0.75=12)就会扩大容量为原来的2倍。(16扩容为32，依次为64,128.....等) 详情见HashMap源码 

添加元素的过程

> 我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为:索引位置），判断数组此位置上是否已经有元素:
>
>  如果此位置上没有其他元素，则元素α添加成功。---->情况1
>
>  如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值: 如果hash值不相同，则元素α添加成功。---->情况2
>
>  如果hash值相同，进而需要调用元素α所在类的equals()方法: 如果equals()返回true,元素α添加失败 如果equals()返回false,则元素α添加成功。---->情况3
>
> 对于添加成功的情况2和情况3而言:元素a与已经存在指定索引位置上数据以链表的方式存储。
>
> jdk7：元素α放到数组中，指向原来的元素。 jdk8：原来的元素在数组中，指向元素α （尾插法）

#### HashMap

###### 1.HashMap的底层原理

> 在jdk1.7之前HashMap是基于数组和[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)实现的，而且采用头插法。
>
> 而jdk1.8 之后在解决哈希冲突时有了较大的变化，当[链表](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)长度大于阈值（默认为 8）（将[链表](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)转换成[红黑树](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为[红黑树](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)）时，将[链表](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)转化为[红黑树](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)，以减少搜索时间。采用尾插法。

![image](https://gitee.com/yishenlaoban/git-typore/raw/master/images/202202281835683.webp)

###### 2.HashMap怎么扩容

HashMap默认的初始化大小为 16。当HashMap中的**元素个数之和**大于负载因子*当前容量的时候就要进行扩充，容量变为原来的 2 倍。（这里注意`不是数组中的个数，而且数组中和链/树中的所有元素个数之和！`）

> 注意：我们还可以在预知存储数据量的情况下，提前设置初始容量（初始容量 = 预知数据量 / 加载因子）。这样做的好处是可以减少 resize() 操作，提高 HashMap 的效率



###### 3.HashMap是线程不安全的吗

HashMap是线程不安全的，其主要体现在：

1. 在jdk1.7中，多线程环境下，扩容时可能会造成环形链或数据丢失
2. 在jdk1.8中，多线程环境下，会发生数据覆盖的情况



###### 4.HashMap扩容的时候为什么是2的n次幂？

数组下标的计算方法是(n - 1) & hash，**取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。”** 并且 **采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。**

###### 5.HashMap使用的hash的实现

> jdk8中，是通过hashCode()的高16异或低16位实现的：(hash = key.hashCode()) ^ (hash >>> 16)，主要是从速度，功效和质量来考虑的，**减少系统的开销**，也不会造成**因为高位没有参与**下标的计算，从而引起的**碰撞**。



**5.1为什么要用异或运算符**

> 保证了对象的hashCode的32位值，只要有一位发生改变，整个hash()的返回值就会改变，尽可能地减少碰撞



###### 6.HashMap的table的容量如何确定？loadFactor是什么？该容量如何变化？这种变化会带来什么问题？

> 1. **table 数组大小**是由 **capacity** 这个参数确定的，默认是**16**，也可以构造时传入，最大限制是1<<30；
> 2. **loadFactor 是装载因子**，主要目的是用来**确认table 数组是否需要动态扩展**，默认值是**0.75**，比如table 数组大小为 16，装载因子为 0.75 时，threshold 就是12，当 table 的实际大小超过 12 时，table就需要动态扩容；
> 3. 扩容时，调用 resize() 方法，将 **table 长度变为原来的两倍**(注意是 **table 长度**，而不是 threshold)
> 4. 如果数据很大的情况下，扩容时将会带来性能的损失，在形内要求很高的地方，这种损失可能会很致命。

###### 7.HashMap的put方法

1. 根据key通过哈希算法和与运算得出数组下标
2. 如果该数组下标元素为空，则将key和value封装为Entry对象(jdk1.7是Entry对象，1.8是Node对象)，并放入该位置
3. 如果数组下标位置元素不为空，则要分情况
   - 如果在jdk1.7中，会`首先判断是否需要扩容`，如果要扩容就先进行扩容，如果不需要则生成Entry对象，并用`头插法`添加到当前链表中。
   - 如果是在jdk1.8中，则会先判断当前位置上的TreeNode类型，看是红黑树还是链表Node
     - 如果是红黑树TreeNode，则会将key和value封装为一个红黑树结点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value
     - 如果此位置上的Node对象时链表结点，则将key和value封装为一个Node并通过`尾插法`插入到链表的最后位置去，因为是尾插法，所以需要遍历链表，遍历的过程中会判断是否存在当前key，如果存在则更新其value，否则遍历完链表后，将新的Node插入到链表，插入后会看当前链表的结点个数，如果大于8，将会将这条链表转为红黑树
     - 将key和value封装为Node插入到链表或红黑树以后，再判断是否需要扩容，如果需要扩容，就结束put方法

###### 8.HashMap，LinkedHashMap，TreeMap有什么区别？它们的使用场景

> - HashMap参考上面的问题；主要用于在Map中插入、删除和定位元素时
>
> - LinkedHashMap保存了记录的插入顺序，在使用Iterator遍历时，先取到的记录肯定是先插入的；遍历比HashMap慢；
>
>   主要用在需要按自然顺序或自定义顺序遍历键值的情况下
>
> - TreeMap实现了SortMap接口，能够把它保存的记录根据key排序(默认按键值升序排序，也可以指定排序的比较器)；
>
>   主要用在需要`输出和输入顺序相同的情况下`

###### 9.HashMap和Hashtable有什么区别

> - `HashMap`是线程不安全的；`Hashtable`是线程安全的；
> - 由于是线程安全的，所以`Hashtable`的效率低于`HashMap`
> - `HashMap`最多只允许一条记录的键为null，允许多条记录的值为null，而`Hashtable`不允许；
> - `HashMap`默认初始化table的大小为16，扩容时扩大为两倍；`Hashtable`初始化为11，扩容为两倍+1
> - `HashMap` 需要重新计算 hash 值，而 `HashTable` 直接使用对象的 hashCode

###### 10.Java 中的另一个线程安全的与 HashMap 极其类似的类是什么？同样是线程安全，它与 HashTable 在线程同步上有什么不同？

> 1. **ConcurrentHashMap** 类（是 Java并发包 java.util.concurrent 中提供的一个**线程安全且高效**的 HashMap 实现）。
> 2. - **HashTable** 是使用 **synchronize** 关键字加锁的原理（就是对**对象**加锁）；
>    - 而针对 **ConcurrentHashMap**，在 **JDK 1.7** 中采用 **分段锁**的方式；**JDK 1.8** 中直接采用了**CAS（无锁算法）+ synchronized**。

###### 11.HashMap & ConcurrentHashMap 的区别？

> 除了加锁，原理上无太大区别。
>
> 另外，**HashMap 的键值对允许有null，但是ConCurrentHashMap 都不允许**。

###### 12.ConcurrentHashMap

> 在jdk1.7是 **分段的数组+[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)** ，jdk1.8的时候跟HashMap1.8的时候一样都是基于数组+[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)/[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)。

ConcurrentHashMap是线程安全的

1. 在jdk1.7的时候是使用分段锁segment，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。
2. 在jdk1.8的时候摒弃了 Segment的概念，而是直接用 Node 数组+[链表](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)+[红黑树](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)的数据结构来实现，并发控制使用 **`synchronized`** 和 **CAS** 来操作。synchronized只锁定当前[链表](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)或红黑[二叉树](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)的首节点

###### 13.为什么 ConcurrentHashMap 比 HashTable 效率要高？

> - **HashTable** 使用**一把锁（锁住整个链表结构）\**处理并发问题，多个线程竞争一把锁，容易\**阻塞**；
> - ConcurrentHashMap
>   - **JDK 1.7** 中使用**分段锁（ReentrantLock + Segment + HashEntry）**，相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：**基于 Segment**，包含多个 HashEntry。
>   - **JDK 1.8** 中使用 **CAS + synchronized + Node + 红黑树**。锁粒度：**Node（首结点）**（实现 Map.Entry<K,V>）。锁粒度降低了。

###### 14.针对 ConcurrentHashMap 锁机制具体分析（JDK 1.7 VS JDK 1.8）？

> **JDK 1.7** 中，采用**分段锁**的机制，实现并发的更新操作，底层采用**数组+链表**的存储结构，包括两个核心静态内部类 **Segment 和 HashEntry**。 ①、**Segment** 继承 **ReentrantLock（重入锁）** 用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶； ②、HashEntry 用来封装映射表的键-值对； ③、每个桶是由若干个 HashEntry 对象链接起来的链表。
>
> ![image-20220303213150748](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220303213150748.png) 
>
> JDK 1.8中，采用Node + CAS + Synchronized来保证并发安全。取消类 Segment，直接用 table 数组存储键值对；当 HashEntry 对象组成的链表长度超过 TREEIFY_THRESHOLD(8)时，链表转换为红黑树，提升性能。底层变更为数组 + 链表 + 红黑树。
>
> ![img](https://gitee.com/yishenlaoban/git-typore/raw/master/images/7779232-1e8ed39548081a1f.png)
>
> ![image-20220303213204100](https://gitee.com/yishenlaoban/git-typore/raw/master/images/image-20220303213204100.png) 

###### 15.ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？

> - **粒度降低了**；
> - JVM 开发团队没有放弃 synchronized，而且基于 JVM 的 synchronized **优化空间更大**，更加自然。
> - 在大量的数据操作下，对于 JVM 的内存压力，基于 API 的 **ReentrantLock 会开销更多的内存**。

###### 16.ConcurrentHashMap简单介绍？

> 1. 重要的常量：
>
>    private transient volatile int **sizeCtl**; 当为负数时，-1 表示正在初始化，-N 表示 N - 1 个线程正在进行扩容； 当为 0 时，表示 table 还没有初始化； 当为其他正数时，表示初始化或者下一次进行扩容的大小。
>
> 2. 数据结构：
>
>    - **Node是存储结构的基本单元**，继承 HashMap 中的 Entry，用于**存储数据**；
>    - **TreeNode 继承 Node**，但是数据结构换成了二叉树结构，是红黑树的存储结构，用于**红黑树中存储数据**；
>    - **TreeBin 是封装 TreeNode 的容器**，提供转换红黑树的**一些条件和锁的控制**。
>
> 3. **存储对象**时（**put()** 方法）：
>
>    1. 如果没有初始化，就调用 initTable() 方法来进行**初始化**;
>    2. 如果没有 hash 冲突就直接 **CAS 无锁插入**；
>    3. 如果需要扩容，就先进行**扩容**；
>    4. 如果存在 hash 冲突，就**加锁**来保证线程安全，两种情况：一种是链表形式就直接遍历到**尾端插入**，一种是红黑树就按照红黑树结构插入；
>    5. 如果该链表的数量大于阀值 8，就要先**转换成红黑树**的结构，break 再一次进入循环；
>    6. 如果添加成功就调用 **addCount() 方法统计 size**，并且**检查是否需要扩容**。
>
> 4. **扩容方法 transfer()**：默认容量为 **16**，扩容时，容量变为原来的**两倍**。 helpTransfer()：调用**多个工作线程**一起帮助进行扩容，这样的效率就会更高。
>
> 5. **获取对象**时（get()方法）：
>
>    1. **计算 hash 值**，定位到该 table 索引位置，如果是首结点符合就返回；
>    2. 如果遇到扩容时，会调用标记正在扩容结点 ForwardingNode.find()方法，查找该结点，匹配就返回；
>    3. 以上都不符合的话，就往下遍历结点，匹配就返回，否则最后就返回 null。

###### 17.ConcurrentHashMap的并发度是什么？

> 程序运行时能够同时更新 ConccurentHashMap 且不产生锁竞争的最大线程数。默认为 16，且可以在构造函数中设置。当用户设置并发度时，ConcurrentHashMap 会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）