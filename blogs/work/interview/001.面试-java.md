---
title: 面试-Java
date: 2022-02-27
categories:
 - 面试
tags:
 - Java面试
sidebar: 'auto'
---

###  JVM

<img src="http://yishenlaoban-img.test.upcdn.net/image_my/image-20220227163139319.png" alt="image-20220227163139319"  />

>   JVM工作机制

![image-20220221225942163](http://yishenlaoban-img.test.upcdn.net/image_my/image-20220221225942163.png)

![image-20220221231144593](http://yishenlaoban-img.test.upcdn.net/image_my/image-20220221231144593.png) 



> GC 垃圾回收机制

![image-20220224151654574](http://yishenlaoban-img.test.upcdn.net/image_my/image-20220224151654574.png) 



> 为什么要进行JVM调优

进行JVM调优，目的是尽可能的减少 `full GC` 的触发（==最好几天一次==），因为GC的线程会有 STW(stop the world),其他线程就会停止（但不会结束），这样就会影响用户体验。然而full GC 处理时间相对 minor GC（处理年轻代的垃圾）会很长。

**模拟：**

线程产生大量数据（秒杀），eden区满了触发minor GC，对象到了Suvivor区；如果Eden区太小，在短时间内又满了触发minor GC,整个新生代回收，线程这时还没有结束它里面引用变量还在，这些对象太大就会到老年代（注意：本来这些对象要在线程结束就要回收的，一直如此下去老年代很快就满了，频繁Full GC）

明白了原因就要解决：让这些对象在新生代待久一些，至少等到当前的秒杀线程结束，再minor GC(这时就会把这个结束线程中的对象回收)，==解决方法：把 JVM 调优新生代的内存调大，这样久一点触发minor GC==

> 为什么会有STW这个机制，怎么就不能GC线程和其他线程一起进行

可达性分析算法中[枚举](https://so.csdn.net/so/search?q=枚举&spm=1001.2101.3001.7020)根节点（GC Roots）会导致所有Java执行线程停顿。分析工作必须在一个能确保一致性的[快照](https://so.csdn.net/so/search?q=快照&spm=1001.2101.3001.7020)中进行
一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证

被STW中断的应用程序线程会在完成GC之后恢复，频繁的中断会让用户感觉像是网速不快造成的电影卡顿一样，所以我们要减少STW的发生



> **什么是字节码？采用字节码的好处是什么？**

**java中的编译器和解释器**：

Java中引入了虚拟机的概念，即在**机器和编译程序之间加入了一层抽象的虚拟的机器**。这台虚拟的机器

在**任何平台**上都提供给编译程序一个的共同的接口。

编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系

统的机器码执行。**在Java中，这种供虚拟机理解的代码叫做 字节码**（即扩展名为 .class的文件），它不

面向任何特定的处理器，只面向虚拟机。

每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节

码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机

器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。

Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执

行的二进制机器码---->程序运行。

**采用字节码的好处：**

Java语言通过字节码的方式，在一定程度上**解决了传统解释型语言执行效率低的问题**，同时又保留了解

释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，

因此，Java程序无须重新编译便可在多种不同的计算机上运行(**跨平台**)。





> **Java类加载器**

JDK自带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。

**BootStrapClassLoader**是ExtClassLoader的父类加载器，默认负责加载**%JAVA_HOME%lib下的jar包和**

**class文件**。

**ExtClassLoader**是AppClassLoader的父类加载器，负责加载%JAVA_HOME%**/lib/ext文件夹下的jar包和**

**class类。**

AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件。系统类加载器，线程上下

文加载器

继承AppClassLoader实现自定义类加载器(为了继续实现**双亲委派机制**)；



> **双亲委派机制**

![image-20220306213403583](http://yishenlaoban-img.test.upcdn.net/images/image-20220306213403583.png) 

双亲委派模型的好处：

* 主要是为了安全性，避免用户自己编写的类动态替换 Java的一些核心类，比如 String。

* 同时也避免了类的重复加载，因为 JVM中区分不同类，不仅仅是根据类名，相同的 class文件被不

同的 ClassLoader加载就是不同的两个类（双亲委派就会保证不会出现一个class加载出两个类）



> **GC如何判断对象可以被回收**

引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计

数为0时可以回收，

**可达性分析法**：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC

Roots 没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。

**引用计数法，可能会出现A 引用了 B，B 又引用了 A，这时候就算他们都不再使用了，但因为相互**

**引用 计数器=1 永远无法被回收。**

GC Roots的对象有：

* 虚拟机栈(栈帧中的本地变量表）中引用的对象

* 方法区中类静态属性引用的对象

* 方法区中常量引用的对象

* 本地方法栈中JNI(即一般说的Native方法)引用的对象





### 面向对象

什么是面向对象？

对比面向过程，是两种不同的处理问题的角度

面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做

什么;

`面向对象`

**封装**：封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项

内部细节对外部调用透明，外部调用无需修改或者关心内部实现

1、javabean的属性私有，提供getset对外访问，因为属性的赋值或者获取逻辑只能由javabean本身决

定。而不能由外部胡乱修改

```java
private String name;
public void setName(String name){
    this.name = "tuling_"+name;
}
该name有自己的命名规则，明显不能由外部直接赋值
```

2、orm框架

操作数据库，我们不需要关心链接是如何建立的、sql是如何执行的，只需要引入mybatis，调方法即可

**继承**：继承基类的方法，并做出自己的改变和/或扩展

子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的

**多态**：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。

继承，方法重写，父类引用指向子类对象

```java
父类类型 变量名 = new 子类对象 ; 

变量名.方法名();
```

`无法调用子类特有的功能	`



### **JDK JRE JVM 区别与联系**

JDK：Java Develpment Kit java 开发工具

JRE：Java Runtime Environment java运行时环境

JVM：java Virtual Machine java 虚拟机

![image-20220227164343230](http://yishenlaoban-img.test.upcdn.net/images/image-20220227164343230.png) 

**工作流程**：

​       JDK是 java 程序员使用的编程工具，写好的java程序，通过java工具包里的`javac`进行编译成`.class`文件（字节码文件），这个文件可以在`windows, linux`机器的`JVM`调用lib类库解释为机器码运行。



### Java异常体系

* 在Java中，异常对象都是派生于Throwable类的一个实例，Java的异常体系如下图所示：

![image-20220308122126558](http://yishenlaoban-img.test.upcdn.net/image_my/image-20220308122126558.png) 

所有的异常都是由Throwable继承而来，在下一层立即分解为两个分支，**Error**和**Exception**。

* **Error错误**：描述了Java运行时系统的内部错误和资源耗尽错误（**OOM**）。一般是指虚拟机相关的问题，如系统崩溃，虚拟机出错误等，**这种错误无法恢复或不可能捕获，将导致应用程序中断**，通常不处理。因为如果出现这样的内部错误，除了通告用户，并尽力使程序安全地终止之外，再也无能为力了。
* **Exception异常**：Java的异常分为两种，**checked Exception**（编译时异常）和 **RuntimeException**（运行时异常）。

1. **checked Exception**（编译时异常）: Java认为checked Exception都是可以在编译阶段被处理的异常，一般是**IOException和SQLException**。所以它**强制程序处理所有的checked Exception**，而RuntimeException无须处理，java程序必须显式处理checked Exception，如果程序没有处理，则在编译时会发生错误，无法通过编译。用try{...}catch{...}finally{...}进行处理或throw和throws抛出异常。
2. **RuntimeException**（运行时异常）：这些异常一般是由程序逻辑错误引起的，**一般都是程序员的错，**表示程序存在bug，所以，一般不需要进行异常处理，直接让程序停止，由调用者对代码进行修正。常见的有NullPointException，IndexOutOfBoundsException（下标越界异常），ClassCastException，ArithmeticException（算数运算异常，例如除数为0等），ArrayStoreException （向数组中存放与声明类型不兼容对象异常），NegativeArraySizeException（创建一个大小为负数的数组错误异常），NumberFormatException（数字格式异常）等



- - 出现运行时异常(**RuntimeException**)后，系统会**自动**把异常一直往上层抛（不需要程序员在代码中抛出），一直遇到处理代码。如果没有处理块，到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了。运行时异常是Exception的子类，也有一般异常的特点，是可以被Catch块处理的。只不过往往我们不对他处理罢了。也就是说，你如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。                                               
  - 如果不想终止，则必须扑捉所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响下面对正常数据的处理。在这个场景这样处理可能是一个比较好的应用，但并不代表在所有的场景你都应该如此。如果在其它场景，遇到了一些错误，如果退出程序比较好，这时你就可以不太理会运行时异常，或者是通过对异常的处理显式的控制程序退出。
-  Java异常处理方法有：**抛出异常，捕捉异常**。主要依赖于**try、catch、finally、throw、throws**五个关键字。 

1.   **try**：它里面放置可能引发异常的代码 
2.  **catch**：后面对应异常类型和一个代码块，用于表明该catch块用于处理这种类型的代码块，可以有多个catch块。 
3.  **finally**：主要用于回收在try块里打开的物力资源（如[数据库](https://cloud.tencent.com/solution/database?from=10680)连接、网络连接和磁盘文件），**异常机制总是保证finally块总是被执行**。只有finally块执行完成之后，才会回来执行try或者catch块中的return或throw语句，如果finally中使用了return或者 throw等终止方法的语句，则就不会跳回执行，直接停止。 
4.  **throw**：用于抛出一个实际的异常，可以单独作为语句使用，抛出一个具体的异常对象。 
5. **throws**：**用在方法签名**中，用于声明该方法可能抛出的异常



### "=="和equals()区别，以及为什么重写了equals要重写**hashCode()**?

**"=="**  : 比较的是`栈中的值`；

*  基本数据类型：就存在栈中，所以比较的是变量值；

* 引用数据类型（类，接口，数组，String）:

​          当他们用 ( == ) 比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为`true`，否则比较后结果为`false`。



**equals** :

​    以为以上的缺陷，引用数据要用equals进行比较，如果我们不重写equals，这里的类都是继承的Object类，而Object类中的equals 方法的实现 也是 `this == object`,比较的还是内存地址；

**重写equals目的是为了：比较对象的值是否相等；**

例如：

```java
public Class User{
    int id;
    int age;
    
    @Override
    public boolean equals(User user){
        return (this.id==user.id && this.age==user.age);
    }
}
```

这样比较的就是对象里每个元素是否相等，从而实现对象是否内容相等；

**String 的equals 实现**：比较每个字符是否相等

```java
public boolean equals(Object anObject) { 
    if (this == anObject) { return true; }
    if (anObject instanceof String) { 
        String anotherString = (String)anObject; 
        int n = value.length; 
        if (n == anotherString.value.length) { 
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++; 
            }
            return true;
        } 
    }
    return false;
}
```



**hashCode:**

​       hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是

确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有

hashCode() 函数。

​       散列表存储的是键值对(key-value)，它的特点是：`能根据“键”快速的检索出对应的“值”`。这其中就利用

到了散列码！（可以快速找到所需要的对象）

​        在Java中,我们一般是在hashSet,hashMap这些集合时使用hashCode，每个对象都可以调⽤⾃⼰的hashCode()⽅法得到⾃⼰的哈希值(hashCode),

然而，如果使用本来的hashCode(),拿到`对象的地址`进行计算得到hash码，这样的话就会有equals结果相同却hashCode不同的出现，hashSet,hashMap使用就没有意义；

hashCode()重写的目的：

​         1、保证equals的结果相同的话计算的hashCode也要相同；

​        `当然可能出现不同的对象有相同的hashCode(hash冲突)`

```java
 @Override
    public int hashCode() {
        int result = Objects.hash(id, age); //用每个元素去做hash
        result = 31 * result + Arrays.hashCode(dynamicTags);
        return result;
    }
```

​         2、对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，重写hashCode()之后，相同的hash就是内容相同，我们就没有必要去比较equals了；如果不同，再去比较equals,，这样既能大大提高了效率也保证了对比的绝对正确性！

这里可以在重写equals里调用hashCode()

```java
public Class User{
    int id;
    int age;
    
    @Override
    public boolean equals(User user){
        if(this.hashCode(user)){ //先比较hash
            return true;
        }else{
             return (this.id==user.id && this.age==user.age);
        }
    }
}
```





### final 和 static 关键字修饰

**final：**

最终的

* 修饰类：表示类不可被继承

* 修饰方法：表示方法不可被子类覆盖，但是可以重载

*  修饰变量：表示变量一旦被赋值就不可以更改它的值。（形参列表的个数和类型不一样）

（1）修饰成员变量

* 如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。

* 如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。

（2）修饰局部变量

系统不会为局部变量进行初始化，局部变量必须由程序员显示初始化。因此使用final修饰局部变量时，

即可以在定义时指定默认值（后面的代码不能对变量再赋值），也可以不指定默认值，而在后面的代码

中对final变量赋初值（仅一次）

```java
public class FinalVar { 
    final static int a = 0;
    //再声明的时候就需要赋值 或者静态代码块赋值 
    /** 
    static{ 
      a = 0; 
    }*/
    final int b = 0;
    //再声明的时候就需要赋值 或者代码块中赋值 或者构造器赋值
    /*{ b = 0; }*/ 
    public static void main(String[] args) { 
         final int localA; 
        //局部变量只声明没有初始化，不会报错,与final无关。
         localA = 0;
        //在使用之前一定要赋值 
        //localA = 1;但是不允许第二次赋值 
    } 
}
```

（3）修饰基本类型数据和引用类型数据

* 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；

* 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。**但是引用的值是可变**

**的**。 (`注意：基本类型包装类和String 是final 修饰的，但是修饰的是对象的值，所以值是不可变的`), 这里是引用变量被修饰，对象的值可以变；

```java
public class FinalReferenceTest{ 
    public static void main(){ 
        final int[] iArr={1,2,3,4}; 
        iArr[2]=-3;//合法 
        iArr=null;//非法，对iArr不能重新赋值 
        
        final Person p = new Person(25);
        p.setAge(24);//合法 
        p=null;//非法 
    } 
}
```

**为什么局部内部类和匿名内部类只能访问局部final变量？**

编译之后会生成两个class文件，Test.class Test1.class

```java
public class Test {
    public static void main(String[] args) { }
    //局部final变量a,b
    public void test(final int b) {//jdk8在这里做了优化,不用写,语法糖，但实际上也是有的，也不能修改 
        final int a = 10; //匿名内部类
        new Thread(){ 
            public void run() { 
                System.out.println(a);
                System.out.println(b);
            }; 
        }.start(); 
    } 
}

class OutClass {
    private int age = 12;
    public void outPrint(final int x) {
        class InClass { 
            public void InPrint() { 
                System.out.println(x);
                System.out.println(age);
                } 
        }
        new InClass().InPrint(); 
    } 
}
```

​        首先需要知道的一点是: `内部类和外部类是处于同一个级别的`，内部类不会因为定义在方法中就会随着

方法的执行完毕就被销毁。

​        这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有没有人再引用它时，才会死亡)。

​        这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，`实际访问的是局部变量的"copy"`。这样就好像延长了局部变量的生命周期;

​       将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修

改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。这实际上也是一种妥协。`使得局部变量与内部类内建立的拷贝保持一致`。

**static （待定）**



### **Integer**

所有整型包装类对象之间值的比较，全部使用equals方法比较。

​        对于Integer var=?在-128至127之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。



### **String、StringBuffer,StringBuilder**

String是final修饰的，不可变，每次操作都会产生新的String对象

StringBuffer和StringBuilder都是在原对象上操作

StringBuffer是线程安全的，StringBuilder线程不安全的

StringBuffer方法都是synchronized修饰的

`性能：StringBuilder > StringBuffer > String`



场景：经常需要改变字符串内容时使用后面两个

优先使用StringBuilder，多线程使用共享变量时使用StringBuffer



### **重载和重写的区别**

**重写**:

重写（Override）是父类与子类之间多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Override)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。

**重载：**

重载（Overload）是一个类中多态性的一种表现。如果在一个类中定义了多个同名的方法，它们参数列表不同，则称为方法的重载(Overload)

**区别：**重载实现于一个类中;重写实现于子类中。

`重载(Overload)`：是一个类中多态性的一种表现，指同一个类中不同的函数使用**相同的函数名**，但是**函数的参数个数或类型不同**。可以有**不同的返回类型**;可以有不同的访问修饰符;可以抛出不同的异常。调用的时候根据函数的参数来区别不同的函数。

`重写（Override):` 是父类与子类之间的多态性，是**子类对父类函数的重新实现**。**函数名和参数与父类一样**，子类与父类**函数体内容不一样**。子类**返回的类型**必须与父类保持一致；子类方法访问修饰符的限制一定要大于父类方法的访问修饰（public>protected>default>private）；子类重写方法一定不能抛出新的检查异常或者比被父类方法申明更加宽泛的检查型异常。**如果父类方法访问修饰符为private则子类就不能重写该方**

**法**

```java
    public int add(int a,String b) 
    public String add(int a,String b) //编译报错
```



### **抽象类和接口的区别**

* 抽象类可以有普通的成员方法，接口中只能存在public abstract 方法;
* 抽象类的成员变量有很多种，而接口的成员变量必须用 public static final 修饰（常量）；
* 抽象类只能继承一个，接口可以实现多个

​    **接口的设计目的**，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有

什么行为），也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，

但不对如何实现行为进行限制。

​    **抽象类的设计目的**，是代码复用。当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行

为的实现方式一致时（A的非真子集，记为B），可以让这些类都派生于一个抽象类。在这个抽象类中实

现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己

实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用到A-B时，无法执

行）。

​      抽象类是对类本质的抽象，表达的是 is a 的关系，比如： BMW is a Car 。抽象类包含并实现子类的通

用特性，将子类存在差异化的特性进行抽象，交由子类去实现。

而接口是对行为的抽象，表达的是 like a 的关系。比如： Bird like a Aircraft （像飞行器一样可以

飞），但其本质上 is a Bird 。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、

是如何实现的，接口并不关心。

**使用场景：**当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。

抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也

是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功

能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计

阶段会降低难度



### 集合

#### List和Set的区别

List：有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出

所有元素，在逐一遍历，还可以使用get(int index)获取指定下标的元素

Set：无序，不可重复，最多允许有一个Null元素对象，取元素时只能用Iterator接口取得所有元

素，在逐一遍历各个元素



#### ArrayList和LinkedList区别

**ArrayList：**基于动态数组，连续内存存储，适合下标访问（随机访问），扩容机制：因为数组长度固

定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会

涉及到元素的移动（往后复制一份，插入新元素），使用**尾插法并指定初始容量可以极大提升性能、甚**

**至超过linkedList（需要创建大量的node对象）**

**LinkedList：**基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询：需要逐

一遍历

遍历LinkedList必须使用iterator**不能使用for循环**，因为每次for循环体内通过get(i)取得某一元素时都需

要对list重新进行遍历(时间复杂度**O(n^2)**)，性能消耗极大。

另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结

果为空时会遍历整个列表。



#### HashMap和HashTable有什么区别？其底层实现是什么？

区别 ： 

（1）HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；

（2）HashMap允许key和value为null，而HashTable不允许

`HashTable的性能太低，现在不怎么用了，一般都用ConcurrentHashMap代替`

2.底层实现：数组+链表实现

jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在

* 计算key的hash值，二次hash然后对数组长度取模，对应到数组下标，

* 如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组，

* 如果产生hash冲突，先进行equal比较，相同则取代该元素，不同，则判断链表高度插入链表，链

 表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表

* key为null，存在下标0的位置

**数组扩容**



#### ConcurrentHashMap原理，jdk7和jdk8版本的区别？

`jdk7`：数据结构：ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每个

HashEntry又是一个链表结构

元素查询：二次hash，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部

锁：Segment分段锁（`锁住一部分的Key,粒度比HashTable更新，效率高`） Segment继承了ReentrantLock，锁定操作的Segment，其他的Segment不受影响，并发度为segment个数，可以通过构造函数指定，数组扩容不会影响其他的segment

**get方法无需加锁，volatile保证**

`jdk8：`

数据结构：synchronized+CAS+Node+红黑树，Node的val和next都用volatile修饰，保证可见性

**查找，替换，赋值操作都使用CAS**, 乐观锁(自旋锁机制)性能高；在扩容和出现哈希冲突的时候，CAS处理不了是用**synchroniaed** 来处理

锁：**锁链表的head节点**，不影响其他元素的读写，**锁粒度更细，效率更高**，扩容时，阻塞所有的读写

操作、并发扩容

读操作无锁：

Node的val和next使用volatile修饰，读写线程对该变量互相可见

数组用volatile修饰，保证扩容时被读线程感知



#### List

##### ArrayList扩容

> 新容量为原数组长度的1.5倍，如果扩容后的容量依然小于需要的容量，就将需要容量作为数组的长度。
>
> 然后将原数组元素拷贝到新的数组并返回

```java
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```

 

##### ArrayList在jdk7、8的不同

1. jdk7

   - ArrayList list = new ArrayList()；//底层elementData数组初始大小为10
   - 执行add()时，如果此次的添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中

2. jdk8

   > 底层elementData初始化为{}，并没有初始化为长度10的数组，而是第一次调用add的时候，底层才创建了长度为10的数组，并将数据加入到数组。后续的添加和扩容操作与JDK7无异

3. 总结：

   > JDK7中的ArrayList的对象创建类似于单例模式中的饿汉式，而JDK8中的类似于懒汉式，延迟了数组的创建，节省了内存



##### HashSet

> 底层也是数组(是一个HashMap)，初始容量为16，当如果使用率超过0.75，(16*0.75=12)就会扩大容量为原来的2倍。(16扩容为32，依次为64,128.....等) 详情见HashMap源码 

添加元素的过程

> 我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为:索引位置），判断数组此位置上是否已经有元素:
>
>  如果此位置上没有其他元素，则元素α添加成功。---->情况1
>
>  如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值: 如果hash值不相同，则元素α添加成功。---->情况2
>
>  如果hash值相同，进而需要调用元素α所在类的equals()方法: 如果equals()返回true,元素α添加失败 如果equals()返回false,则元素α添加成功。---->情况3
>
> 对于添加成功的情况2和情况3而言:元素a与已经存在指定索引位置上数据以链表的方式存储。
>
> jdk7：元素α放到数组中，指向原来的元素。 jdk8：原来的元素在数组中，指向元素α （尾插法）

#### HashMap

###### 1.HashMap的底层原理

> 在jdk1.7之前HashMap是基于数组和[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)实现的，而且采用头插法。
>
> 而jdk1.8 之后在解决哈希冲突时有了较大的变化，当[链表](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)长度大于阈值（默认为 8）（将[链表](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)转换成[红黑树](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为[红黑树](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)）时，将[链表](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)转化为[红黑树](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)，以减少搜索时间。采用尾插法。

![image](http://yishenlaoban-img.test.upcdn.net/images/202202281835683.webp)

###### 2.HashMap怎么扩容

HashMap默认的初始化大小为 16。当HashMap中的**元素个数之和**大于负载因子*当前容量的时候就要进行扩充，容量变为原来的 2 倍。（这里注意`不是数组中的个数，而且数组中和链/树中的所有元素个数之和！`）

> 注意：我们还可以在预知存储数据量的情况下，提前设置初始容量（初始容量 = 预知数据量 / 加载因子）。这样做的好处是可以减少 resize() 操作，提高 HashMap 的效率



###### 3.HashMap是线程不安全的吗

HashMap是线程不安全的，其主要体现在：

1. 在jdk1.7中，多线程环境下，扩容时可能会造成环形链或数据丢失
2. 在jdk1.8中，多线程环境下，会发生数据覆盖的情况



###### 4.HashMap扩容的时候为什么是2的n次幂？

数组下标的计算方法是(n - 1) & hash，**取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。”** 并且 **采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。**

###### 5.HashMap使用的hash的实现

> jdk8中，是通过hashCode()的高16异或低16位实现的：(hash = key.hashCode()) ^ (hash >>> 16)，主要是从速度，功效和质量来考虑的，**减少系统的开销**，也不会造成**因为高位没有参与**下标的计算，从而引起的**碰撞**。



**5.1为什么要用异或运算符**

> 保证了对象的hashCode的32位值，只要有一位发生改变，整个hash()的返回值就会改变，尽可能地减少碰撞



###### 6.HashMap的table的容量如何确定？loadFactor是什么？该容量如何变化？这种变化会带来什么问题？

> 1. **table 数组大小**是由 **capacity** 这个参数确定的，默认是**16**，也可以构造时传入，最大限制是1<<30；
> 2. **loadFactor 是装载因子**，主要目的是用来**确认table 数组是否需要动态扩展**，默认值是**0.75**，比如table 数组大小为 16，装载因子为 0.75 时，threshold 就是12，当 table 的实际大小超过 12 时，table就需要动态扩容；
> 3. 扩容时，调用 resize() 方法，将 **table 长度变为原来的两倍**(注意是 **table 长度**，而不是 threshold)
> 4. 如果数据很大的情况下，扩容时将会带来性能的损失，在形内要求很高的地方，这种损失可能会很致命。

###### 7.HashMap的put方法

1. 根据key通过哈希算法和与运算得出数组下标
2. 如果该数组下标元素为空，则将key和value封装为Entry对象(jdk1.7是Entry对象，1.8是Node对象)，并放入该位置
3. 如果数组下标位置元素不为空，则要分情况
   - 如果在jdk1.7中，会`首先判断是否需要扩容`，如果要扩容就先进行扩容，如果不需要则生成Entry对象，并用`头插法`添加到当前链表中。
   - 如果是在jdk1.8中，则会先判断当前位置上的TreeNode类型，看是红黑树还是链表Node
     - 如果是红黑树TreeNode，则会将key和value封装为一个红黑树结点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value
     - 如果此位置上的Node对象时链表结点，则将key和value封装为一个Node并通过`尾插法`插入到链表的最后位置去，因为是尾插法，所以需要遍历链表，遍历的过程中会判断是否存在当前key，如果存在则更新其value，否则遍历完链表后，将新的Node插入到链表，插入后会看当前链表的结点个数，如果大于8，将会将这条链表转为红黑树
     - 将key和value封装为Node插入到链表或红黑树以后，再判断是否需要扩容，如果需要扩容，就结束put方法

###### 8.HashMap，LinkedHashMap，TreeMap有什么区别？它们的使用场景

> - HashMap参考上面的问题；主要用于在Map中插入、删除和定位元素时
>
> - LinkedHashMap保存了记录的插入顺序，在使用Iterator遍历时，先取到的记录肯定是先插入的；遍历比HashMap慢；
>
>   主要用在需要按自然顺序或自定义顺序遍历键值的情况下
>
> - TreeMap实现了SortMap接口，能够把它保存的记录根据key排序(默认按键值升序排序，也可以指定排序的比较器)；
>
>   主要用在需要`输出和输入顺序相同的情况下`

###### 9.HashMap和Hashtable有什么区别

> - `HashMap`是线程不安全的；`Hashtable`是线程安全的；
> - 由于是线程安全的，所以`Hashtable`的效率低于`HashMap`
> - `HashMap`最多只允许一条记录的键为null，允许多条记录的值为null，而`Hashtable`不允许；
> - `HashMap`默认初始化table的大小为16，扩容时扩大为两倍；`Hashtable`初始化为11，扩容为两倍+1
> - `HashMap` 需要重新计算 hash 值，而 `HashTable` 直接使用对象的 hashCode

###### 10.Java 中的另一个线程安全的与 HashMap 极其类似的类是什么？同样是线程安全，它与 HashTable 在线程同步上有什么不同？

> 1. **ConcurrentHashMap** 类（是 Java并发包 java.util.concurrent 中提供的一个**线程安全且高效**的 HashMap 实现）。
> 2. - **HashTable** 是使用 **synchronize** 关键字加锁的原理（就是对**对象**加锁）；
>    - 而针对 **ConcurrentHashMap**，在 **JDK 1.7** 中采用 **分段锁**的方式；**JDK 1.8** 中直接采用了**CAS（无锁算法）+ synchronized**。

###### 11.HashMap & ConcurrentHashMap 的区别？

> 除了加锁，原理上无太大区别。
>
> 另外，**HashMap 的键值对允许有null，但是ConcurrentHashMap 都不允许**。

###### 12.ConcurrentHashMap

> 在jdk1.7是 **分段的数组+[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)** ，jdk1.8的时候跟HashMap1.8的时候一样都是基于数组+[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)/[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)。

ConcurrentHashMap是线程安全的

1. 在jdk1.7的时候是使用分段锁segment，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。
2. 在jdk1.8的时候摒弃了 Segment的概念，而是直接用 Node 数组+[链表](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)+[红黑树](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)的数据结构来实现，并发控制使用 **`synchronized`** 和 **CAS** 来操作。synchronized只锁定当前[链表](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)或红黑[二叉树](https://file+.vscode-resource.vscode-webview.net/e%3A/张朝昇/学习/Blog/my-notes/docs/06.面试刷题/01.面试/01.java基础.md)的首节点

###### 13.为什么 ConcurrentHashMap 比 HashTable 效率要高？

> - **HashTable** 使用**一把锁（锁住整个链表结构）\**处理并发问题，多个线程竞争一把锁，容易\**阻塞**；
> - ConcurrentHashMap
>   - **JDK 1.7** 中使用**分段锁（ReentrantLock + Segment + HashEntry）**，相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：**基于 Segment**，包含多个 HashEntry。
>   - **JDK 1.8** 中使用 **CAS + synchronized + Node + 红黑树**。锁粒度：**Node（首结点）**（实现 Map.Entry<K,V>）。锁粒度降低了。

###### 14.针对 ConcurrentHashMap 锁机制具体分析（JDK 1.7 VS JDK 1.8）？

> **JDK 1.7** 中，采用**分段锁**的机制，实现并发的更新操作，底层采用**数组+链表**的存储结构，包括两个核心静态内部类 **Segment 和 HashEntry**。 ①、**Segment** 继承 **ReentrantLock（重入锁）** 用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶； ②、HashEntry 用来封装映射表的键-值对； ③、每个桶是由若干个 HashEntry 对象链接起来的链表。
>
> ![image-20220303213150748](http://yishenlaoban-img.test.upcdn.net/images/image-20220303213150748.png) 
>
> JDK 1.8中，采用Node + CAS + Synchronized来保证并发安全。取消类 Segment，直接用 table 数组存储键值对；当 HashEntry 对象组成的链表长度超过 TREEIFY_THRESHOLD(8)时，链表转换为红黑树，提升性能。底层变更为数组 + 链表 + 红黑树。
>
> ![img](http://yishenlaoban-img.test.upcdn.net/images/7779232-1e8ed39548081a1f.png)
>
> ![image-20220303213204100](http://yishenlaoban-img.test.upcdn.net/images/image-20220303213204100.png) 

###### 15.ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？

> - **粒度降低了**；
> - JVM 开发团队没有放弃 synchronized，而且基于 JVM 的 synchronized **优化空间更大**，更加自然。
> - 在大量的数据操作下，对于 JVM 的内存压力，基于 API 的 **ReentrantLock 会开销更多的内存**。

###### 16.ConcurrentHashMap简单介绍？

> 1. 重要的常量：
>
>    private transient volatile int **sizeCtl**; 当为负数时，-1 表示正在初始化，-N 表示 N - 1 个线程正在进行扩容； 当为 0 时，表示 table 还没有初始化； 当为其他正数时，表示初始化或者下一次进行扩容的大小。
>
> 2. 数据结构：
>
>    - **Node是存储结构的基本单元**，继承 HashMap 中的 Entry，用于**存储数据**；
>    - **TreeNode 继承 Node**，但是数据结构换成了二叉树结构，是红黑树的存储结构，用于**红黑树中存储数据**；
>    - **TreeBin 是封装 TreeNode 的容器**，提供转换红黑树的**一些条件和锁的控制**。
>
> 3. **存储对象**时（**put()** 方法）：
>
>    1. 如果没有初始化，就调用 initTable() 方法来进行**初始化**;
>    2. 如果没有 hash 冲突就直接 **CAS 无锁插入**；
>    3. 如果需要扩容，就先进行**扩容**；
>    4. 如果存在 hash 冲突，就**加锁**来保证线程安全，两种情况：一种是链表形式就直接遍历到**尾端插入**，一种是红黑树就按照红黑树结构插入；
>    5. 如果该链表的数量大于阀值 8，就要先**转换成红黑树**的结构，break 再一次进入循环；
>    6. 如果添加成功就调用 **addCount() 方法统计 size**，并且**检查是否需要扩容**。
>
> 4. **扩容方法 transfer()**：默认容量为 **16**，扩容时，容量变为原来的**两倍**。 helpTransfer()：调用**多个工作线程**一起帮助进行扩容，这样的效率就会更高。
>
> 5. **获取对象**时（get()方法）：
>
>    1. **计算 hash 值**，定位到该 table 索引位置，如果是首结点符合就返回；
>    2. 如果遇到扩容时，会调用标记正在扩容结点 ForwardingNode.find()方法，查找该结点，匹配就返回；
>    3. 以上都不符合的话，就往下遍历结点，匹配就返回，否则最后就返回 null。

###### 17.ConcurrentHashMap的并发度是什么？

> 程序运行时能够同时更新 ConccurentHashMap 且不产生锁竞争的最大线程数。默认为 16，且可以在构造函数中设置。当用户设置并发度时，ConcurrentHashMap 会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）







### HashMap扩容的具体步骤

#### jdk7

##### 扩容必须满足的条件

1. `存放新值的时候当前已有的元素个数必须大于等于阈值(threshold=cap*0.75)`
2. `存放新值的时候刚好产生hash碰撞(当前key计算的hash值换算出的数组下标位置已存在值)`

##### put方法的源码

```java
public V put(K key, V value) {
　　　　//判断当前Hashmap(底层是Entry数组)是否存值（是否为空数组）
　　　　if (table == EMPTY_TABLE) {
　　　　　　inflateTable(threshold);//如果为空，则初始化
　　　　}　　　
　　　　//判断key是否为空
　　　　if (key == null)
　　　　　　return putForNullKey(value);//hashmap允许key为空　　　
　　　　//计算当前key的哈希值　　　　
　　　　int hash = hash(key);
　　　　//通过哈希值和当前数据长度，算出当前key值对应在数组中的存放位置
　　　　int i = indexFor(hash, table.length);
　　　　for (Entry<K,V> e = table[i]; e != null; e = e.next) {
　　　　　　Object k;
　　　　　　//如果计算的哈希位置有值（及hash冲突），且key值一样，则覆盖原值value，并返回原值value
　　　　　　if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
　　　　　　　　V oldValue = e.value;
　　　　　　　　e.value = value;
　　　　　　　　e.recordAccess(this);
　　　　　　　　return oldValue;
　　　　　　}
　　　　}
　　　　modCount++;
　　　　//存放值的具体方法
　　　　addEntry(hash, key, value, i);
　　　　return null;
　　}
```

**在put()方法中有调用addEntry()方法，这个方法里面是具体的存值，在存值之前还要判断是否需要扩容**

```java
void addEntry(int hash, K key, V value, int bucketIndex) {
　　　　//1、判断当前个数是否大于等于阈值
　　　　//2、当前存放是否发生哈希碰撞
　　　　//如果上面两个条件否发生，那么就扩容
　　　　if ((size >= threshold) && (null != table[bucketIndex])) {
　　　　　　//扩容，并且把原来数组中的元素重新放到新数组中
　　　　　　resize(2 * table.length);
　　　　　　hash = (null != key) ? hash(key) : 0;
　　　　　　bucketIndex = indexFor(hash, table.length);
　　　　}
　　　　createEntry(hash, key, value, bucketIndex);
　　}
```

**如果需要扩容，调用扩容的方法resize()**

```java
void resize(int newCapacity) {
　　　　Entry[] oldTable = table;
　　　　int oldCapacity = oldTable.length;
　　　　//判断是否有超出扩容的最大值，如果达到最大值则不进行扩容操作
　　　　if (oldCapacity == MAXIMUM_CAPACITY) {
　　　　　　threshold = Integer.MAX_VALUE;
　　　　　　return;
　　　　}
　　　　Entry[] newTable = new Entry[newCapacity];
　　　　// transfer()方法把原数组中的值放到新数组中
　　　　transfer(newTable, initHashSeedAsNeeded(newCapacity));
　　　　//设置hashmap扩容后为新的数组引用
　　　　table = newTable;
　　　　//设置hashmap扩容新的阈值
　　　　threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
　　}
```

**transfer()在实际扩容时候把原来数组中的元素放入新的数组中**

```java
void transfer(Entry[] newTable, boolean rehash) {
　　　　int newCapacity = newTable.length;
　　　　for (Entry<K,V> e : table) {
　　　　　　while(null != e) {
　　　　　　　　Entry<K,V> next = e.next;
　　　　　　　　if (rehash) {
　　　　　　　　　　e.hash = null == e.key ? 0 : hash(e.key);
　　　　　　　　}
　　　　　　　　//通过key值的hash值和新数组的大小算出在当前数组中的存放位置
　　　　　　　　int i = indexFor(e.hash, newCapacity);
　　　　　　　　e.next = newTable[i];
　　　　　　　　newTable[i] = e;
　　　　　　　　e = next;
　　　　　　}
　　　　}
　　}
```



> jdk7及以前使用的是`头插法`(jdk8使用尾插法)
>
> 注：`使用头插法在多线程扩容的时候可能会导致循环指向，从而在获取数据get()的时候陷入死循环，到是线程执行无法结束`

头插法：

`比如[1]->2->3->4->5 1是数组当前的node，如果插入一个0，头插法，链表应该变成[0]->1->2->3->4->5`

> 先插入的会被逐步放到最底下，越后来的会被放在头部，并将next指针指向之前的头部，这样在扩容的时候，先取头部然后把头部放到新对应数组下标的链表处，由于头插法，最早取的会被最先放进并逐步变成最尾，如果多线程执行扩容，将数组下标3位置链表存入的A->B->C扩容时存入到新的数组（假设扩容后A/B/C还在同一个链表上），线程1取第一个元素A被挂起的时候，挂起的元素A元素的next指向B，而线程2放入新的链表时，A被先放但没有完成，线程2在放入B后，B的next指向之前放入的A，当线程1执行的时候本身A的next指向B，这样就行程了循环引用，最后存入C，并将C的next指向B，最终就变成C->B-><-A，在get()方法执行到该数组下标时，遍历链表查找的时候就会出现死循环。

尾插法：

`比如[1]->2->3->4->5 1是数组当前的node，如果插入一个0，尾插法，链表应该变成[1]->2->3->4->5->0`

> 元素插入的时候都是从尾部插入，这样新进来的就在头部，后进来的就在尾部，扩容的时候，先进来的先出，指向next和扩容前方向一致，所以不存在循环指向的问题。

##### 总结

> Hashmap的扩容需要满足两个条件：**当前数据存储的数量（即size()）大小必须大于等于阈值；当前加入的数据是否发生了hash冲突。**
>
> 
>
> 因为上面这两个条件，所以存在下面这些情况
>
> 1. 就是当HashMap存值的时候(默认大小为16，负载因子0.75，阈值12)，可能达到最后存满16个值的时候，再存入第17个值才会发生扩容现象，因为前16个值在底层数组中都分别占据一个位置，并没有发生hash碰撞。
> 2. 当然也可能存储更多值(超过16个值，最多27个值)都还没有扩容。原因：`前11个值全部hash碰撞，存到数组同一下标形成链表(虽然hash冲突，但是这时元素个数size小于阈值12(因为是存入第12个元素之前才判断size)，不会并没有满足扩容的两个条件，所以不会扩容)`。后面15个值分散到数组的剩下15个位置，每个位置一个(`这时元素的个数大于等于阈值，但是每次存入的元素并没有发生hash碰撞，即没有满足扩容的两个条件，所以也不会扩容`)，前面12+15=27，所以在存入第28个值的时候才同时满足上面两个条件，这时才会发生扩容



#### jdk8

##### 扩容条件

> jdk8不再像jdk7一个需要同时满足两个条件，jdk8只需要满足一个条件：
>
> `当存放新值(注意不是替换已有元素位置时)的时候，如果已有元素个数大于等于阈值(已有元素等于阈值，下一个存放必然触发扩容机制)`
>
> 
>
> 注：
>
> 1. 扩容一定是放入新值的时候，该新值不是替换以前位置的情况下(说明：put("name","zhangsan")，而map中原有数据("name","lisi")，这个存放过程就是`替换一个原有值`的过程，不是新增值，不会扩容)
> 2. 扩容数据存放后(`即先存放进去再扩容`)，判断存放后当前的size，如果大于阈值则直接进行扩容

##### 背景知识

> ​	Java7中Hashmap底层采用的是Entry对数组，而每一个Entry对又向下延伸是一个链表，在链表上的每一个Entry对不仅存储着自己的key/value值，还存了前一个和后一个Entry对的地址。
>
> 　　Java8中的Hashmap底层结构有一定的变化，还是使用的数组，但是数组的对象以前是Entry对，现在换成了Node对象（可以理解是Entry对，结构一样，存储时也会存key/value键值对、前一个和后一个Node的地址），以前所有的Entry向下延伸都是链表，Java8变成链表和红黑树的组合，数据少量存入的时候优先还是链表，当链表长度大于8，且总数据量大于64的时候，链表就会转化成红黑树，所以你会看到Java8的Hashmap的数据存储是链表+红黑树的组合，如果数据量小于64则只有链表，如果数据量大于64，且某一个数组下标数据量大于8，那么该处即为红黑树。



##### 源码分析

在jdk7中，初始化HashMap()时就会对其进行初始化，而`jdk8中new HashMap<>()并没有对其进行初始化`，而是在put()方法中通过判断当前table是否等于null，如果为空则调用resize()方法来初始化

```java
public V put(K key, V value) {
	return putVal(hash(key), key, value, false, true);
}
```

```java
/**
     * Implements Map.put and related methods
     *
     * @param hash key值计算传来的下标
     * @param key
     * @param value
     * @param onlyIfAbsent true只是在值为空的时候存储数据，false都存储数据
     * @param evict
     * @return 返回被覆盖的值，如果没有覆盖则返回null
     */
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        // 申明entry数组对象tab[]:当前Entry[]对象
        Node<K,V>[] tab;
        // 申明entry对象p:这里表示存放的单个节点
        Node<K,V> p;
        // n:为当前Entry对象长度 　　　　 // i:为当前存放对象节点的位置下标
        int n, i;
 
        /**
         * 流程判断
         * 1、如果当前Node数组(table)为空，则直接创建(通过resize()创建)，并将当前创建后的长度设置给n
         * 2、如果要存放对象所在位置的Node节点为空，则直接将对象存放位置创建新Node，并将值直接存入
         * 3、存放的Node数组不为空，且存放的下标节点Node不为空（该Node节点为链表的首节点）
         *   1）比较链表的首节点存放的对象和当前存放对象是否为同一个对象，如果是则直接覆盖并将原来的值返回
         *   2）如果不是分两种情况
         *      （1）存储处节点为红黑树node结构，调用方法putTreeVal()直接将数据插入
         *      （2）不是红黑树，则表示为链表，则进行遍历
         *          A.如果存入的链表下一个位置为空，则先将值直接存入，存入后检查当前存入位置是否已经大于链表的第8个位置
         *              a.如果大于,调用treeifyBin方法判断是扩容 还是 需要将该链表转红黑树（大于8且总数据量大于64则转红黑色，否则对数组进行扩容）
         *              b.当前存入位置链表长度没有大于8，则存入成功，终端循环操作。
         *          B.如果存入链表的下一个位置有值，且该值和存入对象“一样”，则直接覆盖，并将原来的值返回
         *          上面AB两种情况执行完成后，判断返回的原对象是否为空，如果不为空，则将原对象的原始value返回
         * 上面123三种情况下，如果没有覆盖原值，则表示新增存入数据，存储数据完成后，size+1,然后判断当前数据量是否大于阈值，
         * 如果大于阈值，则进行扩容。
         */
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            if (p.hash == hash &&
                    ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                // 按照红黑树直接将数据存入
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);//该方法判断是扩容还是需要将该链表转红黑树
                        break;
                    }
                    if (e.hash == hash &&
                            ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        // 如果不是替换数据存入，而是新增位置存入后，则将map的size进行加1，然后判断容量是否超过阈值，超过则扩容
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
```

**treeifyBin**()方法判断是扩容还是将当前链表转为红黑树

> 从指定hash位置处的链表nodes头部开始，全部替换成红黑树结构。
>
> 除非整个数组对象（Map集合）数据量(不是size，size是key个数即元素个数，而是table数组的长度。table 的长度不一定等于size，因为可能发生hash冲突会有的table[i]是链表结构，实际的元素个数是大于table的长度的)很小（小于64），该情况下则通过resize()对这个Map进行扩容，而代替将链表转红黑树的操作。

```java
    final void treeifyBin(HashMap.Node<K,V>[] tab, int hash) {
        int n, index; HashMap.Node<K,V> e;
        // 如果Map为空或者当前存入数据n（可以理解为map的size()）的数量小于64便进行扩容
        if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
            resize();
        // 如果size()大于64则将正在存入的该值所在链表转化成红黑树
        else if ((e = tab[index = (n - 1) & hash]) != null) {
            HashMap.TreeNode<K,V> hd = null, tl = null;
            do {
                HashMap.TreeNode<K,V> p = replacementTreeNode(e, null);
                if (tl == null)
                    hd = p;
                else {
                    p.prev = tl;
                    tl.next = p;
                }
                tl = p;
            } while ((e = e.next) != null);
            if ((tab[index] = hd) != null)
                hd.treeify(tab);
        }
    }
```



##### 总结

> 1. jdk8在新增数据存入后才进行扩容
>
> 2. 扩容发生的条件有两个，满足任意一个都会扩容
>
>    - 存入数据后，size>threshold
>    - 存入数据到某一条链表上，此时链表的长度大于8了，且table数组的length小于64
>
> 3. 注意jdk7、8区别：
>
>    `jdk7是在存入数据前进行判断是否扩容，而jdk8是在存入数据后再进行扩容的判断`



