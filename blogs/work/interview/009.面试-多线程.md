---
title: 面试-多线程
date: 2022-03-08
categories:
 - 面试
tags:
 - 多线程
sidebar: 'auto'
---

## 脑图

<iframe src="https://gitmind.cn/app/doc/df16ab68ebda18d9246533d49968ca9d" width="100%" height="500" frameborder="0" scrolling="No" leftmargin="0" topmargin="0"></iframe>

### **线程的生命周期？线程有几种状态**

1.线程通常有五种状态，**创建**，**就绪**，**运行**、**阻塞**和**死亡**状态。

2.阻塞的情况又分为三种：

(1)、**等待阻塞**：运行的线程执行wait方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待

池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify或notifyAll方法才能被唤

醒，wait是object类的方法

(2)、**同步阻塞**：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放

入“锁池”中。

(3)、**其他阻塞**：运行的线程执行sleep或join方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状

态。当sleep状态超时、join等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

sleep是Thread类的方法



1.**新建状态（New）**：新创建了一个线程对象。

2.**就绪状态（Runnable）**：线程对象创建后，其他线程调用了该对象的start方法。该状态的线程位于

可运行线程池中，变得可运行，等待获取CPU的使用权。

3.**运行状态（Running）**：就绪状态的线程获取了CPU，执行程序代码。

4.**阻塞状态（Blocked）**：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进

入就绪状态，才有机会转到运行状态。

5.**死亡状态（Dead）**：线程执行完了或者因异常退出了run方法，该线程结束生命周期。



### **sleep()、wait()、join()、yield()的区别**

**1.锁池**

​         所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线

程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到

后会进入**就绪队列**进行**等待cpu资源分配**。

**2.等待池**

​         当我们调用**`wait（）`**方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了

notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出一个线程放

到锁池，而notifyAll()是将等待池的所有线程放到锁池当中



1、sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。

2、sleep方法不会释放lock，但是wait会释放，而且会加入到等待队列中。

**sleep 的 线程不会在锁池里去竞争lock资源，只要超时就可以直接竞争cpu资源（就绪）**

3、sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。

4、sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）。

5、sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。

6、sleep 会让出 CPU 执行时间且强制**上下文切换** (`线程切换`)，而 wait 则不一定，wait 后可能还是有机会重新竞

争到锁继续执行的 (就是说如果唤醒的快，立马竞争到lock的话就可以直接执行)。

**yield（）**执行后线程直接进入**就绪状态**，马上释放了cpu的执行权，但是依然保留了cpu的执行资格（**让步：让出当前的cpu竞争**），

所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行

**join（）**执行后线程进入阻塞状态，例如在线程B中调用线程A的join（），那线程B会进入到阻塞队

列，直到线程A结束或中断线程

```java
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(new Runnable() {
        @Override public void run() {
            try {
                Thread.sleep(3000); 
                } catch (InterruptedException e) {
                e.printStackTrace(); 
            }
            System.out.println("22222222");
        } });
    t1.start();
    t1.join();  //main线程等待
    // 这行代码必须要等t1全部执行完毕，才会执行
    System.out.println("1111");
}

22222222 
1111
```





### **对线程安全的理解**

不是线程安全、应该是**内存安全**，堆是共享内存，**可以被所有线程访问**

```html
当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获 得正确的结果，我们就说这个对象是线程安全的
```

​        **堆**是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分

配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了

要还给操作系统，要不然就是内存泄漏。

> 在Java中，堆是Java虚拟机所管理的内存中最大的一块，是所有线程共享的一块内存区域，在虚
>
> 拟机启动时创建。堆所存在的内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及
>
> 数组都在这里分配内存。

​       **栈**是每个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈

互相独立，因此，栈是线程安全的。操作系统在切换线程的时候会自动切换栈。栈空间不需要在高级语

言里面显式的分配和释放。

目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己

的内存空间，而不能访问别的进程的，这是由操作系统保障的。

在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以

访问到该区域，这就是造成问题的潜在原因。





**Thread、Runable的区别**

​          Thread和Runnable的实质是继承关系，没有可比性。无论使用Runnable还是Thread，都会new

Thread，然后执行run方法。用法上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简

单的执行一个任务，那就实现runnable。 

```java
//会卖出多一倍的票
public class Test { 
    public static void main(String[] args) { 
        // TODO Auto-generated method stub
        new MyThread().start(); 
        new MyThread().start(); 
    }
    static class MyThread extends Thread{
        private int ticket = 5;
        public void run(){
            while(true){ 
                System.out.println("Thread ticket = " + ticket--);
                if(ticket < 0){
                    break; 
                } 
            } 
        }
    }
}
```

```java
//正常卖出
public class Test2 {
    public static void main(String[] args) { 
    // TODO Auto-generated method stub 
        MyThread2 mt=new MyThread2();
        new Thread(mt).start(); 
        new Thread(mt).start();
    }
    
    static class MyThread2 implements Runnable{
        private int ticket = 5; 
        public void run(){
            while(true){
                System.out.println("Runnable ticket = " + ticket--);
                if(ticket < 0){
                    break; 
                }
            }
        }
    }
}
```

**原因是：MyThread创建了两个实例，自然会卖出两倍，属于用法错误**





### **对守护线程的理解**

​     守护线程：为所有非守护线程提供服务的线程；**任何一个守护线程都是整个JVM中所有非守护线程的保**

**姆；**

守护线程类似于整个进程的一个默默无闻的小喽喽；它的生死无关重要，它却依赖整个进程而运行；哪

天其他线程结束了，没有要执行的了，程序就结束了，理都没理守护线程，就把它中断了；

**注意： 由于守护线程的终止是自身无法控制的，因此千万不要把IO、File等重要操作逻辑分配给它；因**

**为它不靠谱；**

守护线程的作用是什么？

举例， **GC垃圾回收线程**：就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就

不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线

程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。

应用场景：

（1）来为其它线程提供服务支持的情况；

（2） 或者在任何情况下，程序结束时，这个线程必须正常且立刻关闭，就可以作为守护线程来使用；反之，如果一个正在执行某个操作的线程必须要正确地关闭掉否则就会出现不好的后果的话，那么这个线程就不能是守护线程，而是用户线程。通常都是些关键的事务，比方说，数据库录入或者更新，这些操作都是不能中断的。

  **设置守护线程：**   thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。

在Daemon线程中产生的新线程也是Daemon的。

守护线程不能用于去访问固有资源，比如读写操作或者计算逻辑。因为它会在任何时候甚至在一个操作

的中间发生中断。

Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线

程就不能用Java的线程池。



### **ThreadLocal的原理和使用场景**

​          每一个 Thread 对象均含有一个 `ThreadLocalMap` 类型的成员变量 `threadLocals` ，它存储本线程中所有`ThreadLocal`对象及其对应的值

  `ThreadLocalMap` 由一个个 Entry 对象构成

​        Entry 继承自 `WeakReference<ThreadLocal<?>>` （弱引用），一个 Entry 由 `ThreadLocal` 对象和 Object 构成。由此可见， Entry 的key是`ThreadLocal`对象，并且是一个弱引用。当没指向key的强引用后，该key就会被垃圾收集器回收;

​        当执行set方法时，ThreadLocal首先会**获取当前线程对象**，然后获取当前线程的ThreadLocalMap对

象。再以当前`ThreadLocal对象为key`，将值存储进ThreadLocalMap对象中。

​        get方法执行过程类似。ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap

对象。再以当前ThreadLocal对象为key，获取对应的value。

​        由于每一条线程均含有各自**私有的**ThreadLocalMap容器，这些容器相互独立互不影响，因此不会存在

线程安全性问题，从而也无需使用同步机制来保证多条线程访问容器的互斥性。

**使用场景：**

​    1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。

​    2、线程间数据隔离

​    3、进行事务操作，用于存储线程事务信息。

​    4、数据库连接，Session会话管理。

```JAVA
Spring框架在事务开始时会给当前线程绑定一个Jdbc Connection,在整个事务过程都是使用该线程绑定的 connection来执行数据库操作，实现了事务的隔离性。Spring框架里面就是用的ThreadLocal来实现这种隔离
```

 ![image-20220327194239041](https://img.yishenlaoban.top/image_my/2346254-20220327194239916-473161432.png) 



### **ThreadLocal内存泄露原因，如何避免**

​         内存泄露为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光；

**不再会被使用的对象**或者变量占用的内存**不能被回收**，就是内存泄露。

​     **强引用：**使用最普遍的**引用(new)，反射**，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象。

​    **弱引用：**JVM进行垃圾回收（**触发GC**）时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。

 ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用**弱引用**的ThreadLocal

实例，value为线程变量的副本

![image-20220327195601999](https://img.yishenlaoban.top/image_my/2346254-20220327195602599-766885850.png) 

hreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部**强引用**时，

Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null， 而value还存在着强

引用，只有thead线程退出以后,value的强引用链条才会断掉，但如果当前线程再迟迟不结束的话，这

些key为null的Entry的value就会一直存在一条强引用链（红色链条）

**key 使用强引用**

当hreadLocalMap的key为强引用回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强

引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。

**key 使用弱引用**

当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱

引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调**用**

**set(),get()，remove()方法的时候会被清除value值。**

因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有

手动删除对应key就会导致内存泄漏，而不是因为弱引用。

**ThreadLocal正确的使用方法**

* 每次使用完ThreadLocal都调用它的remove()方法清除数据
* 将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任

何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。





### **并发、并行、串行的区别**

串行在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着

并行在时间上是重叠的，两个任务在**同一时刻互不干扰**的同时执行。

并发允许两个任务彼此干扰。统一时间点、只有一个任务运行，交替执行





### **并发的三大特性**

* **原子性**

原子性是指在一个操作中cpu不可以在中途暂停然后再调度，即不被中断操作，要不全部执行完成，要

不都不执行。就好比转账，从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，

往账户B加上1000元。2个操作必须全部完成。

```java
private long count = 0;
public void calc() {
    count++;
}
```

   * 1：将 count 从主存读到工作内存中的副本中
   * 2：+1的运算
   * 3：将结果写入工作内存
   * 4：将工作内存的值刷回主存(什么时候刷入由操作系统决定，不确定的)

那程序中原子性指的是最小的操作单元，比如自增操作，它本身其实并不是原子性操作，分了3步的，

包括读取变量的原始值、进行加1操作、写入工作内存。所以在多线程中，有可能一个线程还没自增

完，可能才执行到第二部，另一个线程就已经读取了值，导致结果错误。那如果我们能保证自增操作是

一个原子性的操作，那么就能保证其他线程读取到的一定是自增后的数据。

**关键字：**synchronized



* **可见性**

当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

若两个线程在不同的cpu，那么线程1改变了i的值还没刷新到主存，线程2又使用了i，那么这个i值肯定

还是之前的，线程1对变量的修改线程没看到这就是可见性问题。

```java
//线程1 
boolean stop = false; 
while(!stop){ 
    doSomething(); 
}

//线程2 
stop = true;
```

 如果线程2改变了stop的值，线程1一定会停止吗？不一定。当线程2更改了stop变量的值之后，但是还

没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因

此还会一直循环下去。

**关键字：**volatile、synchronized、final



* 有序性

**指令重排：**在单线程中，指令的执行顺序的更改不影响结果，为了提高效率就会指令重排

虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按

照我们写的代码的顺序来执行，有可能将他们重排序。实际上，对于有些代码进行重排序之后，**虽然对**

**变量的值没有造成影响，但有可能会出现线程安全问题（并发的场景下）**。

```java
int a = 0;
bool flag = false;
public void write() { 
    a = 2; //1 
    flag = true; //2 
}

public void multiply() {
    if (flag) {//3 
        int ret = a * a;//4
    } 
}
```

write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，

再到线程1，这时候a才赋值为2,很明显迟了一步

**关键字：**volatile、synchronized

volatile本身就包含了禁止指令重排序的语义，而synchronized关键字是由“一个变量在同一时刻只允许

一条线程对其进行lock操作”这条规则明确的。





### **为什么用线程池？解释下线程池参数？**

> 1、降低资源消耗；提高线程利用率，降低创建和销毁线程的消耗。
>
> 2、提高响应速度；任务来了，直接有线程可用可执行，而不是先创建线程，再执行。
>
> 3、提高线程的可管理性；线程是稀缺资源，使用线程池可以统一分配调优监控。

* **corePoolSize** 代表核心线程数，也就是正常情况下创建工作的线程数，这些线程创建后并不会

消除，而是一种常驻线程

* **maxinumPoolSize** 代表的是最大线程数，它与核心线程数相对应，表示最大允许被创建的线程

数，比如当前任务较多，将核心线程数都用完了，还无法满足需求时，此时就会创建新的线程，但

是线程池内线程总数不会超过最大线程数

* **keepAliveTime 、 unit** 表示超出核心线程数之外的线程的空闲存活时间，也就是核心线程不会

消除，但是超出核心线程数的部分线程如果空闲一定的时间则会被消除,我们可以通过

setKeepAliveTime 来设置空闲时间

* **workQueue** 用来存放待执行的任务，假设我们现在核心线程都已被使用，还有任务进来则全部放

入队列，直到整个队列被放满但任务还再持续进入则会开始创建新的线程

* **ThreadFactory** 实际上是一个线程工厂，用来生产线程执行任务。我们可以选择使用默认的创建

工厂，产生的线程都在同一个组内，拥有相同的优先级，且都不是守护线程。当然我们也可以选择

自定义线程工厂，一般我们会根据业务来制定不同的线程工厂

* **Handler** 任务拒绝策略，有两种情况，第一种是当我们调用 shutdown 等方法关闭线程池后，这

时候即使线程池内部还有没执行完的任务正在执行，但是由于线程池已经关闭，我们再继续想线程

池提交任务就会遭到拒绝。另一种情况就是当达到最大线程数，线程池已经没有能力继续处理新提

交的任务时，这是也就拒绝

![image-20220327204424258](https://img.yishenlaoban.top/image_my/2346254-20220327204425040-712097258.png) 



## 多线程基础

### 创建线程的方式

> **继承Thread类**

```java
public class MyThread extends Thread{//继承Thread类

　　public void run(){undefined

　　//重写run方法

　　}

}
public class Main {undefined

　　public static void main(String[] args){undefined

　　　　new MyThread().start();//创建并启动线程

　　}

}
```



> **实现Runable接口**

```java
//lambda形式
public class Main {

　　public static void main(String[] args){undefined
　　　　new MyThread(()->{
          for (int i = 0; i < 40; i++) {
                ticket.sale();
            }
       },"zcs").start();//创建并启动线程
　　}

}
```



> FuctureTask 实现Callable接口

1】创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。

2】使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值

3】使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）

4】调用FutureTask对象的`get()`方法来获得子线程执行结束后的返回值

```java
 FutureTask<Integer> futureTask = new FutureTask<>(()->{
            System.out.println(Thread.currentThread().getName()+" come in callable");
            return 1024;
 });

 new Thread(futureTask,"lucy").start();
 //调用FutureTask的get方法
 System.out.println(futureTask2.get());
```



> 使用线程池





> synchronized是Java多线程中元老级的锁，也是面试的高频考点，让我们来详细了解synchronized吧。

在Java中，`synchronized`锁可能是我们最早接触的锁了，在 **JDK1.5之前synchronized是一个重量级锁，相对于juc包中的Lock，`synchronized`显得比较笨重**。

庆幸的是在 Java 6 之后 Java 官⽅对从 JVM 层⾯对`synchronized`进行⼤优化，所以现在的 synchronized 锁效率也优化得很不错。

### synchronized 

#### 1、synchronized的作用

`synchronized` 的作用主要有三：

- （1）、**原子性**：**所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。**被`synchronized`修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放。
- （2）、**可见性**：**可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。 **synchronized和volatile都具有可见性，其中synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到共享内存当中，保证资源变量的可见性。
- （3）、**有序性**：**有序性值程序执行的顺序按照代码先后执行。** synchronized和volatile都具有有序性，Java允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性。synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。

#### 2、synchronized的使用

**Synchronized主要有三种用法**：

- （1）、**修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得 **当前对象实例的锁**

```java
synchronized void method() {
  //业务代码
}
```

- （2）、**修饰静态方法:** 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**。因为静态成员不属于任何一个实例对象，是类成员（ *static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份*）。所以，如果一个线程 A 调用一个实例对象的非静态 `synchronized` 方法，而线程 B 需要调用这个实例对象所属类的静态 `synchronized` 方法，是允许的，不会发生互斥现象，**因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁**。

```java
synchronized void staic method() {
  //业务代码
}
```

- （3）、**修饰代码块** ：指定加锁对象，对给定对象/类加锁。`synchronized(this|object)` 表示进入同步代码库前要获得**给定对象的锁**。`synchronized(类.class)` 表示进入同步代码前要获得 **当前 class 的锁**

```java
synchronized(this) {
  //业务代码
}
```

**简单总结一下**：

`synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁。

`synchronized` 关键字加到实例方法上是给对象实例上锁。

接下来看一个 synchronized 使用经典实例—— 线程安全的单例模式：

```java
public class Singleton {
    //保证有序性，防止指令重排
    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public  static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

#### synchronized同步原理

数据同步需要依赖锁，那锁的同步又依赖谁？**synchronized给出的答案是在软件层面依赖JVM，而j.u.c.Lock给出的答案是在硬件层面依赖特殊的CPU指令。**

#### 1、synchronized 同步语句块原理

```java
public class SynchronizedDemo {
	public void method() {
		synchronized (this) {
			System.out.println("synchronized 代码块");
		}
	}
}
```

通过 JDK 自带的 `javap` 命令查看 `SynchronizedDemo` 类的相关字节码信息：首先切换到类的对应目录执行 `javac SynchronizedDemo.java` 命令生成编译后的 .class 文件，然后执行`javap -c -s -v -l SynchronizedDemo.class`。

![image-20210210160804090](https://img.yishenlaoban.top/image_my/2346254-20220424182224504-1734038880.png)

------

从图中可以看出：

`synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置， `monitorexit` 指令则指明同步代码块的结束位置。**

当执行 `monitorenter` 指令时，线程试图获取锁也就是获取 **对象监视器 `monitor`** 的持有权。

> 在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个 `ObjectMonitor`对象。
>
> 另外，**`wait/notify`等方法也依赖于`monitor`对象，这就是为什么只有在同步的块或者方法中才能调用`wait/notify`等方法，否则会抛出`java.lang.IllegalMonitorStateException`的异常的原因。**

在执行`monitorenter`时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。

在执行 `monitorexit` 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。

#### 2、synchronized 修饰方法原理

复制代码

```java
public class SynchronizedDemo2 {
	public synchronized void method() {
		System.out.println("synchronized 方法");
	}
}
```

反编译一下：

![image-20210210161841561](https://img.yishenlaoban.top/image_my/2346254-20220424182224508-1351973373.png)

`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

**简单总结一下**：

`synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。

`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。

**不过两者的本质都是对对象监视器 monitor 的获取。**

### synchronized同步概念

#### 1、Java对象头

在JVM中，对象在内存中的布局分为三块区域：**对象头、实例数据和对齐填充**。

![img](https://img.yishenlaoban.top/image_my/2346254-20220424182402458-274062372.png)

`synchronized`用的锁是存在Java对象头里的。

Hotspot 有两种对象头：

- 数组类型，如果对象是数组类型，则虚拟机用3个字宽 （Word）存储对象头
- 非数组类型：如果对象是非数组类型，则用2字宽存储对象头。

对象头由两部分组成

- Mark Word：存储自身的运行时数据，例如 HashCode、GC 年龄、锁相关信息等内容。
- Klass Pointer：类型指针指向它的类元数据的指针。

64 位虚拟机 Mark Word 是 64bit，在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。

![img](https://img.yishenlaoban.top/image_my/2346254-20220424182402362-1571737890.png)

#### 2、监视器（Monitor）

任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。

1. **MonitorEnter指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；**
2. **MonitorExit指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit；**

那什么是Monitor？可以把它理解为 一个同步工具，也可以描述为 一种同步机制，它通常被 描述为一个对象。

与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，**每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁**。

也就是通常说Synchronized的对象锁，MarkWord锁标识位为10，其中指针指向的是Monitor对象的起始地址。在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的。

### synchronized优化

从JDK5引入了现代操作系统新增加的CAS原子操作（ **JDK5中并没有对synchronized关键字做优化，而是体现在J.U.C中，所以在该版本concurrent包有更好的性能** ），从JDK6开始，就对synchronized的实现机制进行了较大调整，**包括使用JDK5引进的CAS自旋之外，还增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁这些优化策略**。由于此关键字的优化使得性能极大提高，同时语义清晰、操作简单、无需手动关闭，所以推荐在允许的情况下尽量使用此关键字，同时在性能上此关键字还有优化的空间。

锁主要存在四种状态，依次是：**无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态**，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。**但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级**。

![img](https://img.yishenlaoban.top/image_my/2346254-20220424182402229-1510169318.png)

#### 1、偏向锁

偏向锁是JDK6中的重要引进，因为HotSpot作者经过研究实践发现，**在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得**，为了让线程获得锁的代价更低，引进了偏向锁。

当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。

如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。

偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着， 如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

下图中的线 程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程：

![img](https://img.yishenlaoban.top/image_my/2346254-20220424182402790-1336145488.png)

#### 2、轻量级锁

引入轻量级锁的主要目的是 在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。

**（1）轻量级锁加锁**

线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用 CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

**（2）轻量级锁解锁**

轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成 功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

下图是 两个线程同时争夺锁，导致锁膨胀的流程图：

![img](https://img.yishenlaoban.top/image_my/2346254-20220424182402598-1456436146.png)

因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时， 都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

#### 3、锁的优缺点比较

各种锁并不是相互代替的，**而是在不同场景下的不同选择**，绝对不是说重量级锁就是不合适的。**每种锁是只能升级，不能降级，即由偏向锁->轻量级锁->重量级锁**，而这个过程就是开销逐渐加大的过程。

> **如果是单线程使用，那偏向锁毫无疑问代价最小**，并且它就能解决问题，连CAS都不用做，仅仅在内存中比较下对象头就可以了；
>
> **如果出现了其他线程竞争**，则偏向锁就会升级为轻量级锁；
>
> **如果其他线程通过一定次数的CAS尝试没有成功**，则进入重量级锁；

锁的优缺点的对比如下表：

| 锁       | 优点                                                         | 缺点                                             | 适用场景                           |
| -------- | ------------------------------------------------------------ | ------------------------------------------------ | ---------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法仅有纳米级的差距 | 如果线程间存在锁的竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问的同步块场景 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的相应速度                     | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU    | 追求响应时间 同步响应非常快        |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢                           | 追求吞吐量 同步块执行速度较长      |



### Lock

> **大神文章**
>
> **[java里的锁总结（synchronized隐式锁、Lock显式锁、volatile、CAS） - Life_Goes_On - 博客园 (cnblogs.com)](https://www.cnblogs.com/lifegoeson/p/13683785.html)**

上面我们讲到了，synchronized 关键字下层的锁，是在 jvm 层面实现的，而后来在 jdk 5 之后，在 juc 包里有了**显式的锁**，Lock 完全用 Java 写成，在java这个层面是无关JVM实现的。虽然 Lock 缺少了 (通过 synchronized 块或者方法所提供的) 隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种 synchronized 关键字所不具备的同步特性。

Lock 是一个接口，实现类常见的有：

- 重入锁（`ReentrantLock`）
- 读锁（`ReadLock`）
- 写锁（`WriteLock`）

实现基本都是通过**聚合**了一个同步器（`AbstractQueuedSynchronizer` 缩写为` AQS`）的子类来完成线程访问控制的。

这里面的各个锁实现了 Lock 接口，然后任意打开一个类，可以发现里面的实现，Lock 的操作借助于内部类 Sync，而 Sync 是继承了 AbstractQueuedSynchronizer类的，这个类就是很重要的一个 AQS 类。

![image-20220424202025949](https://img.yishenlaoban.top/image_my/2346254-20220424202026174-1181567675.png) 



#### AbstractQueuedSynchronizer

队列同步器 AbstractQueuedSynchronizer(以下简称同步器或者 AQS)，是用来构建锁或者其他同步组件的基础框架，它使用了一个 int 成员变量表示同步状态，通过**内置的 FIFO 队列**来完成资源获取线程的排队工作。

同步器的主要**使用方式是继承**，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的 3 个方法来进行操作，因为它们能够保证状态的改变是安全的。

这三个方法分别是：

1. `protected final int getState()`// 获取当前同步状态
2. `protected final void setState(int newState)`// 设置当前同步状态
3. `protected final boolean compareAndSetState(int expect, int update)`// 使用 CAS 设置当前状态，该方法能够保证状态设置的原子性

子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件 `(ReentrantLock、 ReentrantReadWriteLock 和 CountDownLatch 等)`。

AQS 定义的三类模板方法；

1. **独占式**同步状态获取与释放
2. **共享式**同步状态获取与释放
3. 同步状态和查询**同步队列**中的等待线程情况

同步器的内置 FIFO 队列，从源码里可以看到，Node 就是**保存着线程引用和线程状态的容器**。

- 每个线程对同步器的访问，都可以看做是队列中的一个节点（Node）。
- 节点是构成同步队列的基础，同步器拥有首节点 (head) 和尾节点 (tail)；
- 没有成功获取同步状态的线程将会成为节点加入该队列的尾部。
- 首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。



#### **重入锁 ReentrantLock**

- 重入锁 `ReentrantLock`，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。
- 除此之外，该锁的还支持获取锁时的公平和非公平性选择。

`ReentrantLock` 支持公平与非公平选择，内部实现机制为：

1. 内部基于` AQS` 实现一个公平与非公平公共的父类 Sync，（在代码里，Sync 是一个内部类，继承 AQS）用于管理同步状态；
2. `FairSync `继承 Sync 用于处理公平问题；
3. `NonfairSync` 继承 Sync 用于处理非公平问题。





#### **读写锁 ReentrantReadWriteLock**

在上面讲 synchronized 的最后，提到了锁的其他维度的分类：

独占锁（排他锁）/共享锁，具体实现层面就对应 java 里的**互斥锁/读写锁**。

- `ReentrantLock`、synchronized 都是排他锁；
- `ReentrantReadWriteLock`
  里面维护了一个读锁、一个写锁，其中读锁是共享锁，写锁是排他锁。

![image-20220424202755825](https://img.yishenlaoban.top/image_my/2346254-20220424202756012-1836691565.png) 

因为分了读写锁，`ReentrantReadWriteLock` 锁没有直接实现 Lock 接口，它的内部是这样的：

- 基于 `AQS`实现一个公平与非公平公共的父类 Sync，用于管理同步状态；
- `FairSync`继承 Sync 用于处理公平问题；
- `NonfairSync` 继承 Sync用于处理非公平问题；
- `ReadLock`实现 Lock 接口，内部聚合 Sync；
- `WriteLock` 实现 Lock 接口，内部聚合 Sync。



### Synchronized和Lock 总结对比

到这里我们知道了 **java 的对象都有与之关联的一个锁**，这个锁称为监视器锁（Monitor）或者内部锁，通过关键字 `synchronized` 声明来使用，实际是 jvm 层面实现的，向下则用到了 Monitor 类，再向下虚拟机的指令则是和 CPU 打交道，插入内存屏障等等操作。

而 jdk 5 之后引入了**显式的锁**，以 Lock 接口为核心的各种实现类，他们完全由 java 实现逻辑，那么实现类还要基于 AQS 这个队列同步器，AQS 屏蔽了同步状态管理、线程排队与唤醒等底层操作，提供模板方法，聚合到 Lock 的实现类里去实现。

这里我们对比一下隐式和显式锁：

1. **隐式锁**基本没有灵活性可言，因为 synchronized 控制的代码块无法跨方法，修饰的范围很窄；而显**示锁**则本身就是一个对象，可以充分发挥面向对象的灵活性，完全可以在一个方法里获得锁，另一个方法里释放。
2. **隐式锁**简单易用且不会导致内存泄漏；而**显式锁**的过程完全要程序员控制，容易导致锁泄露；
3. **隐式锁**只是非公平锁；**显示锁**支持公平/非公平锁；
4. **隐式锁**无法限制等待时间、无法对锁的信息进行监控；**显示锁**提供了足够多的方法来完成灵活的功能；
5. 一般来说，我们默认情况下使用隐式锁，只在需要显示锁的特性的时候才选用显式锁。

对比完了 synchronized 和 Lock 两个**锁**。对于 java 的线程同步机制，往往还会提到的另外两个内容就是 

volatile 关键字和 CAS 操作以及对应的原子类。

因此这里再提一下：

- `volatile`

   关键字常被称为轻量级的 synchronized，实际上这两个完全不是一个东西。我们知道了 synchronized 通过的是 jvm 层面的管程隐式的加了锁。而 volatile 关键字则是另一个角度，jvm 也采用相应的手段，保证：

  - 被它修饰的变量的可见性：线程对变量进行修改后，要立刻写回主内存；
  - 线程对变量读取的时候，要从主内存读，而不是缓存；
  - 在它修饰变量上的操作禁止指令重排序。

- `CAS`

   是一种 CPU 的指令，也不属于加锁，它通过假设没有冲突而去试探性的完成操作，如果因为冲突失败了就重试，直到成功。那么实际上我们很少直接使用 CAS ，但是 java 里提供了一些原子变量类，就是 juc 包里面的各种`Atomicxxx`类，这些**类的底层实现直接使用了 CAS 操作**来保证使用这些类型的变量的时候，操作都是**原子操作**，当使用他们作为共享变量的时候，也就不存在线程安全问题了。



### volatile 关键字

我们先要从 **CPU 缓存模型** 说起！

####  CPU 缓存模型

**为什么要弄一个 CPU 高速缓存呢？**

类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 **CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。**

我们甚至可以把 **内存可以看作外存的高速缓存**，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。

总结：**CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。**

为了更好地理解，我画了一个简单的 CPU Cache 示意图如下（实际上，现代的 CPU Cache 通常分为三层，分别叫 L1,L2,L3 Cache）:

![cpu-cache](https://img.yishenlaoban.top/image_my/2346254-20220427202117679-1604413563.png)

**CPU Cache 的工作方式：**

先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 **内存缓存不一致性的问题** ！比如我执行一个 i++操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 1++运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。

**CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议或者其他手段来解决。**

#### 讲一下 JMM(Java 内存模型)

Java 内存模型抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。Java 内存模型主要目的是为了屏蔽系统和硬件的差异，避免一套代码在不同的平台下产生的效果不一致。

在 JDK1.2 之前，Java 的内存模型实现总是从**主存**（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存**本地内存**（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成**数据的不一致**。

> - **主内存** ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)
> - **本地内存** ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。

![JMM(Java 内存模型)](https://img.yishenlaoban.top/image_my/2346254-20220427202117701-215428359.png)

要解决这个问题，就需要把变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

所以，**`volatile` 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。**

![volatile关键字可见性](https://img.yishenlaoban.top/image_my/2346254-20220427202117678-1533581943.png)

####  并发编程的三个重要特性

1. **原子性** : 一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。`synchronized` 可以保证代码片段的原子性。
2. **可见性** ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。`volatile` 关键字可以保证共享变量的可见性。
3. **有序性** ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。`volatile` 关键字可以禁止指令进行重排序优化。

#### 说说 synchronized 关键字和 volatile 关键字的区别

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在！

- **`volatile` 关键字**是线程同步的**轻量级实现**，所以 **`volatile `性能肯定比`synchronized`关键字要好** 但是 **`volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块** 。
- **`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。**
- **`volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性**



### ThreadLocal



