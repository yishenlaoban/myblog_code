---

title: 面试-多线程
date: 2022-03-08
categories:
 - 面试
tags:
 - 多线程
sidebar: 'auto'
---



### **线程的生命周期？线程有几种状态**

1.线程通常有五种状态，**创建**，**就绪**，**运行**、**阻塞**和**死亡**状态。

2.阻塞的情况又分为三种：

(1)、**等待阻塞**：运行的线程执行wait方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待

池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify或notifyAll方法才能被唤

醒，wait是object类的方法

(2)、**同步阻塞**：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放

入“锁池”中。

(3)、**其他阻塞**：运行的线程执行sleep或join方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状

态。当sleep状态超时、join等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

sleep是Thread类的方法



1**.新建状态（New）**：新创建了一个线程对象。

2.**就绪状态（Runnable）**：线程对象创建后，其他线程调用了该对象的start方法。该状态的线程位于

可运行线程池中，变得可运行，等待获取CPU的使用权。

3.**运行状态（Running）**：就绪状态的线程获取了CPU，执行程序代码。

4.**阻塞状态（Blocked）**：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进

入就绪状态，才有机会转到运行状态。

5.**死亡状态（Dead）**：线程执行完了或者因异常退出了run方法，该线程结束生命周期。







### **sleep()、wait()、join()、yield()的区别**

**1.锁池**

​         所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线

程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到

后会进入**就绪队列**进行**等待cpu资源分配**。

**2.等待池**

​         当我们调用**`wait（）`**方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了

notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出一个线程放

到锁池，而notifyAll()是将等待池的所有线程放到锁池当中



1、sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。

2、sleep方法不会释放lock，但是wait会释放，而且会加入到等待队列中。

**sleep 的 线程不会在锁池里去竞争lock资源，只要超时就可以直接竞争cpu资源（就绪）**

3、sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。

4、sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）。

5、sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。

6、sleep 会让出 CPU 执行时间且强制**上下文切换** (`线程切换`)，而 wait 则不一定，wait 后可能还是有机会重新竞

争到锁继续执行的 (就是说如果唤醒的快，立马竞争到lock的话就可以直接执行)。

**yield（）**执行后线程直接进入**就绪状态**，马上释放了cpu的执行权，但是依然保留了cpu的执行资格（**让步：让出当前的cpu竞争**），

所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行

**join（）**执行后线程进入阻塞状态，例如在线程B中调用线程A的join（），那线程B会进入到阻塞队

列，直到线程A结束或中断线程

```java
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(new Runnable() {
        @Override public void run() {
            try {
                Thread.sleep(3000); 
                } catch (InterruptedException e) {
                e.printStackTrace(); 
            }
            System.out.println("22222222");
        } });
    t1.start();
    t1.join();  //main线程等待
    // 这行代码必须要等t1全部执行完毕，才会执行
    System.out.println("1111");
}

22222222 
1111
```





### **对线程安全的理解**

不是线程安全、应该是**内存安全**，堆是共享内存，**可以被所有线程访问**

```html
当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获 得正确的结果，我们就说这个对象是线程安全的
```

​        **堆**是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分

配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了

要还给操作系统，要不然就是内存泄漏。

> 在Java中，堆是Java虚拟机所管理的内存中最大的一块，是所有线程共享的一块内存区域，在虚
>
> 拟机启动时创建。堆所存在的内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及
>
> 数组都在这里分配内存。

​       **栈**是每个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈

互相独立，因此，栈是线程安全的。操作系统在切换线程的时候会自动切换栈。栈空间不需要在高级语

言里面显式的分配和释放。

目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己

的内存空间，而不能访问别的进程的，这是由操作系统保障的。

在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以

访问到该区域，这就是造成问题的潜在原因。





**Thread、Runable的区别**

​          Thread和Runnable的实质是继承关系，没有可比性。无论使用Runnable还是Thread，都会new

Thread，然后执行run方法。用法上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简

单的执行一个任务，那就实现runnable。 

```java
//会卖出多一倍的票
public class Test { 
    public static void main(String[] args) { 
        // TODO Auto-generated method stub
        new MyThread().start(); 
        new MyThread().start(); 
    }
    static class MyThread extends Thread{
        private int ticket = 5;
        public void run(){
            while(true){ 
                System.out.println("Thread ticket = " + ticket--);
                if(ticket < 0){
                    break; 
                } 
            } 
        }
    }
}
```

```java
//正常卖出
public class Test2 {
    public static void main(String[] args) { 
    // TODO Auto-generated method stub 
        MyThread2 mt=new MyThread2();
        new Thread(mt).start(); 
        new Thread(mt).start();
    }
    
    static class MyThread2 implements Runnable{
        private int ticket = 5; 
        public void run(){
            while(true){
                System.out.println("Runnable ticket = " + ticket--);
                if(ticket < 0){
                    break; 
                }
            }
        }
    }
}
```

**原因是：MyThread创建了两个实例，自然会卖出两倍，属于用法错误**





### **对守护线程的理解**

​     守护线程：为所有非守护线程提供服务的线程；**任何一个守护线程都是整个JVM中所有非守护线程的保**

**姆；**

守护线程类似于整个进程的一个默默无闻的小喽喽；它的生死无关重要，它却依赖整个进程而运行；哪

天其他线程结束了，没有要执行的了，程序就结束了，理都没理守护线程，就把它中断了；

**注意： 由于守护线程的终止是自身无法控制的，因此千万不要把IO、File等重要操作逻辑分配给它；因**

**为它不靠谱；**

守护线程的作用是什么？

举例， **GC垃圾回收线程**：就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就

不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线

程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。

应用场景：

（1）来为其它线程提供服务支持的情况；

（2） 或者在任何情况下，程序结束时，这个线程必须正常且立刻关闭，就可以作为守护线程来使用；反之，如果一个正在执行某个操作的线程必须要正确地关闭掉否则就会出现不好的后果的话，那么这个线程就不能是守护线程，而是用户线程。通常都是些关键的事务，比方说，数据库录入或者更新，这些操作都是不能中断的。

  **设置守护线程：**   thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。

在Daemon线程中产生的新线程也是Daemon的。

守护线程不能用于去访问固有资源，比如读写操作或者计算逻辑。因为它会在任何时候甚至在一个操作

的中间发生中断。

Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线

程就不能用Java的线程池。



