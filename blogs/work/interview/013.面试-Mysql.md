---
title: 面试-Mysql
date: 2022-04-28
categories:
 - 面试
tags:
 - Mysql
sidebar: 'auto'
---


## 脑图

<iframe src="https://gitmind.cn/app/doc/4a18296cbd3fa4e56752fadd3b7e557f" width="100%" height="500" frameborder="0" scrolling="No" leftmargin="0" topmargin="0"></iframe>


## 事务隔离级别

### ACID原则

::: note

- 原子性：事务满足原子性，所有操作要么都执行成功，要么都不执行
- 一致性：事物开始和完成时，数据都必须保持一致状。比如：如果从A账户转账到B账户，不可能A账户扣了钱，而B账户没有加钱
- 隔离性：并发环境中，各事务之间的执行不被其它事务干扰，即不同的并发事务操作相同的数据时，每个事务都有自己的完整数据空间
- 持久性：事务对数据库的操作是写入磁盘，哪怕宕机重新运行也是事务结束后的状态

:::

### Read Uncommitted（读取未提交内容）

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

脏读的具体示例如下：

| 时间点 | 事务A               | 事务B          |
| :----- | :------------------ | :------------- |
| 1      | 开启事务            |                |
| 2      |                     | 开启事务       |
| 3      | 查询数据为100条     |                |
| 4      |                     | insert一条数据 |
| 5      | 再查询，结果为101条 |                |

在时间点5，事务A再次查询数据时，事务B并没有提交事务，但是，新的数据也被事务A查出来了。这就是脏读。

### Read Committed（读取提交内容）

这是大多数[数据库](https://cloud.tencent.com/solution/database?from=10680)系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

| 时间点 | 事务A           | 事务B          |
| :----- | :-------------- | :------------- |
| 1      | 开启事务        |                |
| 2      |                 | 开启事务       |
| 3      | 查询数据为100条 |                |
| 4      |                 | insert一条数据 |
| 5      | 查询数据为100条 |                |
| 6      |                 | 提交事务       |
| 7      | 查询数据为101条 |                |

我们可以看到，事务B在提交事务之前，事务A的两次查询结果是一致的。事务B提交事务以后，事务A再次查询，查询到了新增的这条数据。在事务A中，多次查询的结果不一致，这就是我们说的“不可重复读”。

### Repeatable Read（可重读）

这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。

上面这一段是MySQL官方给出的解释，听着云里雾里。“可重读”这种隔离级别解决了上面例子中的问题，保证了同一事务内，多次查询的结果是一致的。也就是说，事务B插入数据提交事务后，事务A的查询结果也是100条，因为事务A在开启事务时，事务B插入的数据还没有提交。

**但是，这又引出了另外一个情况，“幻读”。**这个幻读我之前理解是有问题的，在面试时，被对方一顿质疑。**现在我们就看看幻读的正确理解：**

| 时间点 | 事务A                  | 事务B          |
| :----- | :--------------------- | :------------- |
| 1      | 开启事务               |                |
| 2      |                        | 开启事务       |
| 3      | 查询数据“张三”，不存在 |                |
| 4      |                        | 插入数据“张三” |
| 5      |                        | 提交事务       |
| 6      | 查询数据“张三”，不存在 |                |
| 7      | 插入数据“张三”，不成功 |                |

**事务A查询“张三”，查询不到，插入又不成功，“张三”这条数据就像幻觉一样出现。这就是所谓的“幻读”**。网上对“幻读”还是其他的解释，都是错误的。**比如像“幻读”和“不可重复读”是一样，只不过“幻读”是针对数据的个数。这些理解都是错误的。**

### Serializable（可串行化）

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。这种隔离级别很少使用，不给大家做过多的介绍了。



## 索引类别原理相关

::: tip

索引对查询速度有至关重要的影响，理解索引也是进行数据库性能调优的起点，索引就是为了提高数据查询的效率。`索引可以包含一个或多个列的值`，如果索引包含多个列的值，则`列的顺序`也十分重要，因为MySQL只能高效地使用索引的最左前缀列

:::

### 索引类别

#### 哈希索引

::: tip 概念

哈希表是一种以键-值（key-value）的方式存储数据的结构，我们只要输入待查找的值（即key），就可以找到其对应的值（即Value）。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置，即index = Hash(key)。如果出现哈希冲突，就采用拉链法解决(还有开放定址法：线性或左右平方跳跃)。

因为哈希表中存放的数据不是有序的，因此不适合做区间查询，适用于只有等值查询的场景

:::

#### 有序数组

::: tip 概念

有序数组在等值查询和范围查询场景中的性能都非常优秀。用二分法就可以快速找到（时间复杂度为O(logN)）。但是如果要往中间插入一条数据，则必须挪动后面的所有记录，成本较高。因此，有序数组只适用于静态存储引擎，即数据表一旦建立后不再会修改

:::

#### B+树索引(InnoDB)

> 简单的说，是因为使用B+树存储数据可以让一个查询尽量少的读磁盘，从而减少查询时磁盘I/O的时间。
>
> 在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。

假设，有这样一张表：该表主键为ID，且还有一个字段为k，并在k上有索引。

```sql
CREATE TABLE T( id int primary key,    k int not null,    index (k) )engine=InnoDB;
```

表中有5条记录，分别为R1~R5，(100,1)、(200,2)、(300,3)、(500,5)和(600,6)。则在InnoDB中的索引组织结构是这样的： 

![image-20220425183531187](https://img.yishenlaoban.top/image_my/image-20220425183531187.png)

根据叶子结点的内容，索引类型分为主键索引和非主键索引。

- 主键索引的叶子结点存的是整条记录，主键索引也被称为聚簇索引（clustered index）。

- 非主键索引的叶子结点存的是主键的值，非主键索引也被称为二级索引（secondary index）/普通索引/辅助索引。

那么，基于主键索引和非主键索引的查询有什么区别？

- 如果语句是 select * from T where ID=500，即主键查询，则只需要搜索ID这棵树。

- 如果语句是 select * from T where k=5，即非主键索引查询，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。从非主键索引回到主键索引的过程称为`回表`。

也就是说，`基于非主键索引的查询需要多扫描一棵索引树`。因此，我们在应用中应该尽量使用主键查询。而从存储空间的角度讲，`因为非主键索引树的叶结点存放的是主键的值`，那么，应该考虑让主键的字段尽量短，这样非主键索引的叶子结点就越小，非主键索引占用的空间也就越小。一般情况下，`建议创建一个自增主键，这样非主键索引占用的空间最小`



#### 联合索引

> 联合索引是指对表上的多个列进行索引。下面以一个例子进行说明。假设有下面这样一张表，有这样一个需求，我们需要查询某个用户的购物情况，并按照时间进行排序，取出某用户近几次的购物情况。（注：例子来源于《MySQL技术内幕》）

```sql
# 表
CREATE TABLE buylog(    userid int not null,    buy_date DATE )ENGINE=InnoDB; 
# 插入数据 
insert into buylog values(1, '2019-08-13'); insert into buylog values(2, '2019-08-14'); 
insert into buylog values(3, '2019-08-15'); insert into buylog values(1, '2019-08-11'); 
insert into buylog values(3, '2019-08-10'); insert into buylog values(1, '2019-08-12'); 
# 添加索引 
alter table buylog add index(userid); 
alter table buylog add index(userid, buy_date); 
# （或用key关键字也一样的） 
alter table buylog add key(userid); 
alter table buylog add key(userid, buy_date); 
```

上面的代码建立了两个索引，两个索引都包含了userid字段。

如果只对于userid进行查询，如：

```sql
select * from buylog where userid=2;
```

通过explain查看该语句的执行情况如下：

![image-20220425190520837](https://img.yishenlaoban.top/image_my/image-20220425190520837.png)



可以看到，possible_keys有两个索引可选，一个是`useridandbugdate_index`(两个字段的联合索引)和`userid_index`(userid的单索引)，MySQL最终选择的是联合索引，貌似是版本优化了，走的联合索引，实际上原来是走的单值索引`userid_index`



接着要查询userid=1的最近两次的购买记录，执行的情况：

```sql
EXPLAIN select * from buylog where userid=1 order by buy_date desc limit 2;
```

![image-20220425191150469](https://img.yishenlaoban.top/image_my/image-20220425191150469.png)

> 这一次查询优化器选择的索引(userid, buy_date)联合索引，因为因为在这个联合索引中，`记录已经分别根据userid和buy_date排好序了`，利用这个索引则可以直接取出相应的数据而`无需再对buy_date额外做一次排序操作`了

如果强制使用userid索引，则它的执行计划如下： 

![image-20220425191425941](https://img.yishenlaoban.top/image_my/image-20220425191425941.png)

> 从Extra字段可以看出，该语句的执行需要使用fliesort，也就是需要一次额外的排序操作才能完成查询。显然，这个排序就是对buy_date字段的排序，`因为这里仅使用了userid索引，该索引未对buy_date进行排序`



#### 最左前缀原则

> 对于有很多字段的一张表，查询的方式是多样的，难道要为了每一种可能的查询都定义索引吗？这样岂不是很浪费空间，毕竟建索引也是需要一些空间的。事实上，B+ 树这种索引结构，可以利用索引的“最左前缀”原则来定位记录，避免重复定义索引。

![image-20220425191731541](https://img.yishenlaoban.top/image_my/image-20220425191731541.png)

::: tip

假设建立了一个联合索引(name,age)，可以看到，索引项是按照索引定义里面出现的字段顺序排序的，先根据名字排序，名字相同的就根据年龄排序。

当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。

如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是"where name like '张%'"。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。

可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。`这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符`。

因此，基于最左前缀原则，我们在定义联合索引的时候，考虑如何安排索引内的字段顺序就至关重要了！评估的标准就是索引的复用能力，比如，`当已经有了(a,b)字段的索引，一般就不需要再单独在a上建立索引了`。这里其实可以映射到上面联合索引的例子，为什么第一条SQL只查userid的时候用的还是联合索引

:::



#### 覆盖索引

<Badge text="还是用这张表进行说明"/>

```sql
CREATE TABLE T( id int primary key,    k int not null,    index (k) )engine=InnoDB;
```

如果执行的语句是：

```sql
select * from T where k between 3 and 5
```

则这条SQL执行流程如下：

::: warning

1. 在 k 索引树上找到 k=3 的记录，取得 ID = 300；

2. 再到 ID 索引树查到 ID=300 对应的 R3；

3. 在 k 索引树取下一个值 k=5，取得 ID=500；

4. 再回到 ID 索引树查到 ID=500 对应的 R4；

5. 在 k 索引树取下一个值k=6，不满足条件，循环结束。

:::

> 在这个过程中，回到主键索引树根据ID去查询的过程，称为回表。在这个例子中，`由于查询的结果是所有字段，所需要的数据只有主键上才有，所以不得不回表`。但如果执行的语句是下面这样的，注意！这里查询的结果只是“ID”（恰好是主键），而不是所有字段了。

```sql
select ID from T where k between 3 and 5;
```

> 因为k字段的索引是辅助索引(二级索引)，其根节点上存放的是k字段值和主键值，所以主键ID的值已经在字段k的索引树上了，因此可以直接提供查询结果，不会触发回表，也就是说，在这个查询里，索引k已经"覆盖了"我们的查询需求，故称为覆盖索引



> 除了上面这种情况，针对某些统计问题时，覆盖索引也能发挥用处。还是以上面的例子，执行如下语句来统计表的记录总数（在此我们假设这张表数据量特别特别大，需要多次磁盘IO）：
>
> ```sql
> select count(*) from T;
> ```
>
> 如果没有对字段k设置索引，那么只能是通过聚簇索引来计算；如果对字段k设置了索引，那么，`由于聚簇索引的叶结点存放的是整行记录的所有信息，而辅助索引的叶结点只存放主键`，两者相比，`对于一页内存，显然辅助索引能够存放的节点更多`，意味着辅助索引可以`减少IO次数`，从而更快的计算出count(*)的值。

测试一下：用buylog表，先把userid的单列索引删掉，联合索引也删掉，不然会走联合索引，然后执行SQL

```sql
EXPLAIN select count(*) from buylog;
```

![image-20220425193651140](https://img.yishenlaoban.top/image_my/image-20220425193651140.png)

<Badge text="可以看到，优化器选择主键聚簇索引进行操作"/>



把索引加上后：

![image-20220425193857404](https://img.yishenlaoban.top/image_my/image-20220425193857404.png)

<Badge text="可以看到，优化器选择了单值辅助索引进行操作。如果单值没有，则使用联合索引"/>

> 可见，如果建立了辅助索引，在有些场景下，优化器会自动使用辅助索引从而提升查询效率



::: danger 总结

覆盖索引就是从辅助索引中就能直接得到查询结果，而不需要回表到聚簇索引中进行再次查询，所以可以减少搜索次数（不需要从辅助索引树回表到聚簇索引树），或者说`减少IO操作（通过辅助索引树可以一次性从磁盘载入更多节点）`，从而提升性能

:::



#### 索引下推

> 什么是索引下推（Index Condition Pushdown，ICP）呢？
>
> 假设有这么个需求，查询表中“名字第一个字是张，性别男，年龄为10岁的所有记录”。那么，查询语句是这么写的：
>
> ```sql
> select * from tuser where name like '张 %' and age=10 and ismale=1;
> ```
>
> 根据前面说的“最左前缀原则”，该语句在搜索索引树的时候，只能匹配到名字第一个字是‘张’的记录（即记录ID3），接下来是怎么处理的呢？当然就是从ID3开始，逐个回表，到主键索引上找出相应的记录，再比对age和ismale这两个字段的值是否符合。
>
> 但是！MySQL 5.6引入了索引下推优化，`可以在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数`

下面分别展示这两种情况：

图1：没有索引下推的时候

![image-20220425194338507](https://img.yishenlaoban.top/image_my/image-20220425194338507.png)

图2：有索引下推的时候

![image-20220425194404154](https://img.yishenlaoban.top/image_my/image-20220425194404154.png)

::: tip 注意

图 1 中，在 (name,age) 索引里面特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把"name 第一个字是'张'"的记录一条条取出来回表。因此，需要回表 4 次。

图 2 跟图 1 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。

:::



::: danger 总结

如果没有索引下推优化（或称ICP优化），当进行索引查询时，首先根据索引来查找记录，然后再根据where条件来过滤记录；在支持ICP优化后，MySQL会在取出索引的同时，判断是否可以进行where条件过滤，也就是说提前执行where的部分过滤操作，在某些场景下，可以大大减少回表次数，从而提升整体性能

:::